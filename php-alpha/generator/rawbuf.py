#!/usr/bin/python
#author: jobs
#email: yao050421103@gmail.com
import sys
import os.path
import datetime
import string
import json

CTYPE = 0
NAME = 1
ID = 2
CREATOR = 3

FILTER = '@null_string_place_holder'
merge = lambda l: string.join(filter(lambda item: FILTER != item, l), '\n')
json_filter = lambda f: (lambda f, l: os.path.splitext(f)[1] in l)(f, ['.json'])

def manual(): 
    print """
    usage:
        python rawbuf.py [option] filelist
            [option]
                -f: use file in filelist
                -p: use dir in filelist, will be parsed recursive
                
    sample:
        python rawbuf.py -f file1.json file2.json file3.json
        python rawbuf.py -p ./dir1/ ./dir2/ ./dir3/
        """

def get_file_list(cur_dir, path_filter):
    def __get(cur_dir, path_filter, file_list):
        for root, dirs, files in os.walk(cur_dir): 
            for f in files:
                if path_filter(f):
                    file_list.append(os.path.join(root, f))
    file_list = []
    __get(cur_dir, path_filter, file_list)
    return file_list

def get_files(file_filter, op, urls):
    if '-f' == op:
        return filter(file_filter, urls)
    elif '-p' == op:
        file_set = set()
        for url in urls:
            for item in get_file_list(url, file_filter):
                if not item in file_set:
                    file_set.add(item)
        return list(file_set)
    return []

def write_file(url, data):
    with open(url, 'w') as f:
        f.writelines(data)

def get_scalar_dict():
    return {
        'bool': 'rb_bool_t',
        'int8_t': 'rb_int8_t',
        'uint8_t': 'rb_uint8_t',
        'short': 'rb_int16_t',
        'int16_t': 'rb_int16_t',
        'uint16_t': 'rb_uint16_t',
        'int': 'rb_int32_t',
        'int32_t': 'rb_int32_t',
        'uint32_t': 'rb_uint32_t',
        'long': 'rb_int64_t',
        'int64_t': 'rb_int64_t',
        'uint64_t': 'rb_uint64_t',
        'float': 'rb_float_t',
        'double': 'rb_double_t'
        }

def get_header():
    return merge([
        '////////////////////////////////////////////////////////////////////////////////',
        '// NOTE : Generated by rawbuf. It is NOT supposed to modify this file.',
        '////////////////////////////////////////////////////////////////////////////////'
        ])
def gen_func_frame(func, imp):
    return merge([
    '    public function %s' % func,
    '    {',
    imp,
    '    }'
    ])
def get_member_methods():
    
    __eq = lambda ctype, members, method: gen_func_frame('eq($other)', merge([
        merge(['        if (!$this->%s->eq($other->%s)) return false;' % (member[NAME], member[NAME]) for member in members]),
        '        return true;'
        ]))
    __reset = lambda ctype, members, method: gen_func_frame('reset()', merge([
        '        $this->%s->reset();' % member[NAME] for member in members
        ]))
    __assign = lambda ctype, members, method: gen_func_frame('assign($other)', merge([
        '        $this->%s->assign($other->%s);' % (member[NAME], member[NAME]) for member in members
        ]))
    __encode = lambda ctype, members, method: gen_func_frame('encode($buf)', merge([
        '        $index = 0;',
        merge(['        if (!$this->__skip_%s && !rb_encode_field($index++, $this->__id_%s, $this->%s, $buf)) return false;' % (
            member[NAME], member[NAME], member[NAME]) for member in members]),
        '        return true;'
        ]))
    __decode = lambda ctype, members, method: gen_func_frame('decode($id, $offset, $buf)', merge([
        '        $rc = new rb_bool_t(true);',
        merge(['        if (rb_decode_field($this->__id_%s, $id, $offset, $buf, $rc, $this->__rb_has_%s, $this->%s)) return $rc->val;' % (
            member[NAME], member[NAME], member[NAME]) for member in members]),
        '        return $rc->val;'
        ]))
    __rb_fields = lambda ctype, members, method: gen_func_frame('rb_fields()', merge([
        '        $fields = 0;',
        merge(['        if (!$this->__skip_%s) $fields++;' % member[NAME] for member in members]),
        '        return $fields;'
        ]))
    __rb_size = lambda ctype, members, method: gen_func_frame('rb_size()', merge([
        '        $fields = 0;',
        '        $size = 0;',
        merge([merge([
            '        if (!$this->__skip_%s)' % member[NAME],
            '        {',
            '            $size += $this->%s->rb_size();' % member[NAME],
            '            $fields++;',
            '        }'
            ]) for member in members]),
        '        $size += rb_seek_field_table_item($fields);',
        '        $size += rb_scalar_t::rb_size(rb_buf_end_t);',
        '        return $size;'
        ]))
    return [__eq, __reset, __assign, __encode, __decode, __rb_fields, __rb_size]

def gen_from_schema(path, obj, scalar_dict, member_methods):
    def __check(structs):
        for struct in structs:
            ctype = struct['type']
            if not ctype.endswith('_t'):
                print '"%s" is not end with "_t"' % ctype
                return False
            ids = set()
            for member in struct['members']:
                if len(member) > (ID + 1) or len(member) < (ID):
                    print 'invalid members: "%s" in struct "%s"' % (str(member), ctype)
                    return False
                if len(member) < (ID + 1):
                    continue
                id = member[ID]
                if int(id) > 255:
                    print 'invalid id (should be: [0, 255]): "%s" in struct "%s"' % (str(member), ctype)
                    return False
                if id in ids:
                    print '"%s" duplicated in "%s"' % (str(id), ctype)
                    return False
                else:
                    ids.add(id)
        return True
    def __get_creator(nested, key, scalar_dict):
        def __get_base_creator(nested, key, scalar_dict):
            format_str = lambda nested: 'array(%s, null)' if nested else 'new %s()'
            if 'rb_list_t' == key or 'rb_dict_t' == key:
                raise TypeError("invalid key")
            if key in scalar_dict:
                return format_str(nested) % scalar_dict[key]
            return format_str(nested) % key
        is_array = lambda key: key.startswith('[') and key.endswith(']')
        is_dict = lambda key: key.startswith('{') and key.endswith('}')
        base_type = lambda key: key[1:len(key) - 1]
        if is_array(key):
            return 'new rb_list_t(%s)' % __get_creator(True, base_type(key), scalar_dict)
        if is_dict(key):
            return 'new rb_dict_t(%s)' % __get_creator(True, base_type(key), scalar_dict)
        if 'string' == key:
            return 'array(rb_string_t, null)' if nested else 'new rb_string_t()'
        return __get_base_creator(nested, key, scalar_dict)
    def __update_object(obj, scalar_dict):
        def __update_ids(members):
            ids = [member[ID] for member in filter(lambda member: len(member) > ID, members)]
            default_ids = [str(members.index(member)) for member in members]
            for id in default_ids:
                if id in ids:
                    default_ids.remove(id)
            for member in members:
                if not len(member) > ID:
                    id = default_ids[0]
                    member.append(id)
                    default_ids.remove(id)
        for struct in obj['structs']:
            __update_ids(struct['members'])
            for member in struct['members']:
                member.append(__get_creator(False, member[CTYPE], scalar_dict))
    def __gen_implement(path, obj, scalar_dict, member_methods):
        def __gen_struct(struct, scalar_dict, member_methods):
            __gen_def = lambda ctype, members: merge([
                'class %s' % ctype,
                '{',
                '    // fields',
                merge(['    public $%s;' % member[NAME] for member in members]),
                '    // ids',
                merge(['    private $__id_%s;' % member[NAME] for member in members]),
                '    // flags',
                merge(['    private $__skip_%s;' % member[NAME] for member in members]),
                merge(['    private $__rb_has_%s;' % member[NAME] for member in members]),
                '    public function __construct()',
                '    {',
                '        // fields',
                merge(['        $this->%s = %s;' % (member[NAME], member[CREATOR]) for member in members]),
                '        // ids',
                merge(['        $this->__id_%s = %s;' % (member[NAME], member[ID]) for member in members]),
                '        // flags',
                merge(['        $this->__skip_%s = false;' % member[NAME] for member in members]),
                merge(['        $this->__rb_has_%s = new rb_bool_t();' % member[NAME] for member in members]),
                '    }',
                merge([gen_func_frame('skip_%s()' % member[NAME], '        $this->__skip_%s = true;' % member[NAME]) for member in members]),
                merge([gen_func_frame('rb_has_%s()' % member[NAME], '        return $this->__rb_has_%s->val;' % member[NAME]) for member in members])
                ])
            __gen_wrap_methods = merge([
                gen_func_frame('rb_encode($rb_val)', '        return rb_encode_base($this, $rb_val);'),
                gen_func_frame('rb_decode($rb_val, $offset)', '        return rb_decode_base($rb_val, $offset, $this);'),
                gen_func_frame('rb_dump($path)', '        return rb_dump_base($this, $path);'),
                gen_func_frame('rb_load($path)', '        return rb_load_base($path, $this);'),
                '}',
                '',
                ])
            return merge([
                __gen_def(struct['type'], struct['members']),
                merge([method(struct['type'], struct['members'], method) for method in member_methods]),
                __gen_wrap_methods
                ])
        write_file(path + ".php", merge([
            '<?php',
            get_header(),
            '',
            'require_once "rawbuf.php";',
            '',
            merge([__gen_struct(struct, scalar_dict, member_methods) for struct in obj['structs']]),
            '?>'
            ]))
    if not __check(obj['structs']):
        return False
    __update_object(obj, scalar_dict)
    __gen_implement(path, obj, scalar_dict, member_methods)
    return True

def gen(file_list, scalar_dict, member_methods):
    for path_item in file_list:
        with open(path_item, 'r') as f:
            obj = json.load(f)
            gen_from_schema(
                path_item[:path_item.rfind('.')], 
                obj, 
                scalar_dict,
                member_methods)
    return True

def parse_shell(argv):
    size = len(argv)
    if 1 == size or 2 == size:
        return False
    op = argv[1]
    file_list = get_files(json_filter, op, argv[2:])
    return gen(
        file_list, 
        get_scalar_dict(), 
        get_member_methods()
        ) if len(file_list) > 0 else False

if __name__ == "__main__":
    if not parse_shell(sys.argv):
        manual()