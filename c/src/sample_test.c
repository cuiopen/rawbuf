////////////////////////////////////////////////////////////////////////////////
// NOTE : Generated by rawbuf. It is NOT supposed to modify this file.
////////////////////////////////////////////////////////////////////////////////
#include "sample_test.h"
#ifdef WIN32
#define true  1
#define false 0
#else
#include <stdbool.h>
#endif

void rb_init_sample_struct(sample_struct_t * obj_val)
{
    if (!obj_val)
    {
        return;
    }
    memset(obj_val, 0, sizeof(sample_struct_t));

    rb_init_int8(&obj_val->int8_val);
    obj_val->id_int8_val = 0;
    obj_val->skip_int8_val = false;
    obj_val->rb_has_int8_val = false;

    rb_init_uint8(&obj_val->uint8_val);
    obj_val->id_uint8_val = 1;
    obj_val->skip_uint8_val = false;
    obj_val->rb_has_uint8_val = false;

    rb_init_string(&obj_val->str_val);
    obj_val->id_str_val = 100;
    obj_val->skip_str_val = false;
    obj_val->rb_has_str_val = false;

    rb_init_string_array(&obj_val->str_arr_val);
    obj_val->id_str_arr_val = 2;
    obj_val->skip_str_arr_val = false;
    obj_val->rb_has_str_arr_val = false;

    rb_init_string_dict(&obj_val->str_dict_val);
    obj_val->id_str_dict_val = 3;
    obj_val->skip_str_dict_val = false;
    obj_val->rb_has_str_dict_val = false;
}

rb_bool_t rb_set_sample_struct(const sample_struct_t * src, sample_struct_t * dst)
{
    if (!src || !dst)
    {
        return false;
    }
    dst->id_int8_val = src->id_int8_val;
    dst->id_uint8_val = src->id_uint8_val;
    dst->id_str_val = src->id_str_val;
    dst->id_str_arr_val = src->id_str_arr_val;
    dst->id_str_dict_val = src->id_str_dict_val;
    do
    {
        if (!rb_set_int8(&src->int8_val, &dst->int8_val)) break;
        if (!rb_set_uint8(&src->uint8_val, &dst->uint8_val)) break;
        if (!rb_set_string(&src->str_val, &dst->str_val)) break;
        if (!rb_set_string_array(&src->str_arr_val, &dst->str_arr_val)) break;
        if (!rb_set_string_dict(&src->str_dict_val, &dst->str_dict_val)) break;

        return true;
    } while (0);

    return false;
}

rb_bool_t rb_eq_sample_struct(const sample_struct_t * src, const sample_struct_t * dst)
{
    if (!src || !dst)
    {
        return false;
    }
    do
    {
        if (!rb_eq_int8(&src->int8_val, &dst->int8_val)) break;
        if (!rb_eq_uint8(&src->uint8_val, &dst->uint8_val)) break;
        if (!rb_eq_string(&src->str_val, &dst->str_val)) break;
        if (!rb_eq_string_array(&src->str_arr_val, &dst->str_arr_val)) break;
        if (!rb_eq_string_dict(&src->str_dict_val, &dst->str_dict_val)) break;

        return true;
    } while (0);

    return false;
}

void rb_dispose_sample_struct(sample_struct_t * obj_val)
{
    if (!obj_val)
    {
        return;
    }
    rb_dispose_int8(&obj_val->int8_val);
    rb_dispose_uint8(&obj_val->uint8_val);
    rb_dispose_string(&obj_val->str_val);
    rb_dispose_string_array(&obj_val->str_arr_val);
    rb_dispose_string_dict(&obj_val->str_dict_val);
}

rb_field_size_t rb_fields_sample_struct(const sample_struct_t * obj_val)
{
    rb_field_size_t fields = 0;
    if (!obj_val->skip_int8_val) ++fields;
    if (!obj_val->skip_uint8_val) ++fields;
    if (!obj_val->skip_str_val) ++fields;
    if (!obj_val->skip_str_arr_val) ++fields;
    if (!obj_val->skip_str_dict_val) ++fields;
    return fields;
}

rb_size_t rb_sizeof_sample_struct(const sample_struct_t * obj_val)
{
    rb_field_size_t fields = 0;
    rb_size_t size = 0;
    if (!obj_val->skip_int8_val)
    {
        size += rb_sizeof_int8(&obj_val->int8_val);
        ++fields;
    }
    if (!obj_val->skip_uint8_val)
    {
        size += rb_sizeof_uint8(&obj_val->uint8_val);
        ++fields;
    }
    if (!obj_val->skip_str_val)
    {
        size += rb_sizeof_string(&obj_val->str_val);
        ++fields;
    }
    if (!obj_val->skip_str_arr_val)
    {
        size += rb_sizeof_string_array(&obj_val->str_arr_val);
        ++fields;
    }
    if (!obj_val->skip_str_dict_val)
    {
        size += rb_sizeof_string_dict(&obj_val->str_dict_val);
        ++fields;
    }
    size += rb_seek_field_table_item(fields);
    size += sizeof(rb_buf_end_t);
    return size;
}

rb_bool_t rb_encode_sample_struct(const sample_struct_t * obj_val, rb_buf_t * rb_val)
{
    rb_buf_t buf = rb_nested_buf(rb_val, 0);
    if (buf.size < 1)
    {
        return false;
    }
    do
    {
        rb_field_size_t fields = rb_fields_sample_struct(obj_val);
        rb_field_size_t index = 0;
        if (!rb_set_field_count(fields, &buf)) break;

        if (!obj_val->skip_int8_val)
        {
            if (!rb_set_field_table_item(index++, obj_val->id_int8_val, buf.pos - buf.start, &buf)) break;
            if (!rb_encode_int8(&obj_val->int8_val, &buf)) break;
        }
        if (!obj_val->skip_uint8_val)
        {
            if (!rb_set_field_table_item(index++, obj_val->id_uint8_val, buf.pos - buf.start, &buf)) break;
            if (!rb_encode_uint8(&obj_val->uint8_val, &buf)) break;
        }
        if (!obj_val->skip_str_val)
        {
            if (!rb_set_field_table_item(index++, obj_val->id_str_val, buf.pos - buf.start, &buf)) break;
            if (!rb_encode_string(&obj_val->str_val, &buf)) break;
        }
        if (!obj_val->skip_str_arr_val)
        {
            if (!rb_set_field_table_item(index++, obj_val->id_str_arr_val, buf.pos - buf.start, &buf)) break;
            if (!rb_encode_string_array(&obj_val->str_arr_val, &buf)) break;
        }
        if (!obj_val->skip_str_dict_val)
        {
            if (!rb_set_field_table_item(index++, obj_val->id_str_dict_val, buf.pos - buf.start, &buf)) break;
            if (!rb_encode_string_dict(&obj_val->str_dict_val, &buf)) break;
        }

        if (!rb_set_buf_size(buf.pos - buf.start + sizeof(rb_buf_end_t), &buf)) break;
        if (!rb_encode_end(fields, &buf)) break;
        rb_val->pos = buf.pos;

        return true;
    } while (0);

    return false;
}

static rb_bool_t __decode_sample_struct(
    const rb_field_table_item_t * item,
    const rb_buf_t * rb_val,
    sample_struct_t * obj_val)
{
    if (item->id == obj_val->id_int8_val)
    {
        rb_bool_t rc = rb_decode_int8(rb_val, item->offset, &obj_val->int8_val);
        if (rc)
        {
            obj_val->rb_has_int8_val = true;
        }
        return rc;
    }
    if (item->id == obj_val->id_uint8_val)
    {
        rb_bool_t rc = rb_decode_uint8(rb_val, item->offset, &obj_val->uint8_val);
        if (rc)
        {
            obj_val->rb_has_uint8_val = true;
        }
        return rc;
    }
    if (item->id == obj_val->id_str_val)
    {
        rb_bool_t rc = rb_decode_string(rb_val, item->offset, &obj_val->str_val);
        if (rc)
        {
            obj_val->rb_has_str_val = true;
        }
        return rc;
    }
    if (item->id == obj_val->id_str_arr_val)
    {
        rb_bool_t rc = rb_decode_string_array(rb_val, item->offset, &obj_val->str_arr_val);
        if (rc)
        {
            obj_val->rb_has_str_arr_val = true;
        }
        return rc;
    }
    if (item->id == obj_val->id_str_dict_val)
    {
        rb_bool_t rc = rb_decode_string_dict(rb_val, item->offset, &obj_val->str_dict_val);
        if (rc)
        {
            obj_val->rb_has_str_dict_val = true;
        }
        return rc;
    }
    return true;
}

rb_bool_t rb_decode_sample_struct(const rb_buf_t * rb_val, rb_offset_t offset, sample_struct_t * obj_val)
{
    if (!obj_val)
    {
        return false;
    }
    rb_buf_t buf = rb_nested_buf(rb_val, offset);
    if (buf.size < 1)
    {
        return false;
    }
    rb_field_table_head_t head = rb_get_field_table_head(&buf);
    if (head.fields < 1 || !rb_check_code(&buf, &head))
    {
        return false;
    }
    rb_field_table_item_t item = { 0, 0 };
    rb_field_size_t i = 0;
    for (i = 0; i < head.fields; ++i)
    {
        if (!rb_get_field_table_item(i, &buf, &item))
        {
            return false;
        }
        if (item.offset >= head.size)
        {
            return false;
        }
        if (item.offset > 0 && !__decode_sample_struct(&item, &buf, obj_val))
        {
            return false;
        }
    }
    return true;
}

static rb_bool_t __dump_sample_struct(const void * obj_val, rb_buf_t * buf)
{
    return rb_encode_sample_struct((sample_struct_t *) obj_val, buf);
}

rb_bool_t rb_dump_sample_struct(const sample_struct_t * obj_val, const char * path)
{
    if (!obj_val || !path)
    {
        return false;
    }
    rb_size_t size = rb_sizeof_sample_struct(obj_val);
    if (size < 1)
    {
        return false;
    }
    return rb_dump_buf(__dump_sample_struct, obj_val, size, path);
}

static rb_bool_t __load_sample_struct(const rb_buf_t * buf, void * obj_val)
{
    return rb_decode_sample_struct(buf, 0, (sample_struct_t *) obj_val);
}

rb_bool_t rb_load_sample_struct(const char * path, sample_struct_t * obj_val)
{
    return rb_load_buf(path, __load_sample_struct, obj_val);
}

sample_struct_array_t rb_create_sample_struct_array(rb_size_t capacity)
{
    sample_struct_array_t obj_val = { capacity, 0, 0 };
    if (capacity > 0)
    {
        rb_size_t len = capacity * sizeof(sample_struct_t);
        obj_val.arr = (sample_struct_t *) rb_malloc(len);
        memset(obj_val.arr, 0, len);
        rb_size_t i = 0;
        for (i = 0; i < capacity; ++i)
        {
            rb_init_sample_struct(obj_val.arr + i);
        }
    }
    return obj_val;
}

rb_bool_t rb_append_to_sample_struct_array(const sample_struct_t * item, sample_struct_array_t * obj_val)
{
    if (!item || !obj_val || !obj_val->arr || obj_val->size >= obj_val->capacity)
    {
        return false;
    }
    sample_struct_t * dst = obj_val->arr + obj_val->size;
    if (rb_set_sample_struct(item, dst))
    {
        ++obj_val->size;
        return true;
    }
    return false;
}

void rb_init_sample_struct_array(sample_struct_array_t * obj_val)
{
    if (!obj_val || !obj_val->arr || obj_val->capacity < 1)
    {
        return;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->capacity; ++i)
    {
        rb_init_sample_struct(obj_val->arr + i);
    }
}

rb_bool_t rb_set_sample_struct_array(const sample_struct_array_t * src, sample_struct_array_t * dst)
{
    if(!src || !src->arr || !dst)
    {
        return false;
    }
    if (src->size < 1)
    {
        memset(dst, 0, sizeof(sample_struct_array_t));
        return true;
    }
    *dst = rb_create_sample_struct_array(src->size);
    dst->size = src->size;
    rb_size_t i = 0;
    for (i = 0; i < dst->size; ++i)
    {
        if (!rb_set_sample_struct(src->arr + i, dst->arr + i))
        {
            rb_dispose_sample_struct_array(dst);
            return false;
        }
    }
    return true;
}

rb_bool_t rb_eq_sample_struct_array(const sample_struct_array_t * src, const sample_struct_array_t * dst)
{
    if(!src || !dst)
    {
        return false;
    }
    if (!src->arr && !dst->arr)
    {
        return true;
    }
    if(!src->arr || !dst->arr || (src->size != dst->size))
    {
        return false;
    }
    rb_size_t i = 0;
    for (i = 0; i < src->size; ++i)
    {
        if (!rb_eq_sample_struct(src->arr + i, dst->arr + i))
        {
            return false;
        }
    }
    return true;
}

void rb_dispose_sample_struct_array(sample_struct_array_t * obj_val)
{
    if (!obj_val || !obj_val->arr)
    {
        return;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        rb_dispose_sample_struct(obj_val->arr + i);
    }
    rb_free(obj_val->arr);
    memset(obj_val, 0, sizeof(sample_struct_array_t));
}

rb_size_t rb_sizeof_sample_struct_array(const sample_struct_array_t * obj_val)
{
    rb_size_t size = sizeof(rb_size_t) + obj_val->size * sizeof(rb_size_t);
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        size += rb_sizeof_sample_struct(obj_val->arr + i);
    }
    return size;
}

rb_bool_t rb_encode_sample_struct_array(const sample_struct_array_t * obj_val, rb_buf_t * rb_val)
{
    if (!obj_val || !obj_val->arr)
    {
        return false;
    }
    rb_buf_t buf = rb_nested_buf(rb_val, 0);
    if (buf.size < 1)
    {
        return false;
    }
    if (!rb_set_array_count(obj_val->size, &buf))
    {
        return false;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        if (!rb_set_array_table_item(i, buf.pos - buf.start, &buf))
        {
            return false;
        }
        if (!rb_encode_sample_struct(obj_val->arr + i, &buf))
        {
            return false;
        }
    }
    rb_val->pos = buf.pos;
    return true;
}

rb_bool_t rb_decode_sample_struct_array(const rb_buf_t * rb_val, rb_offset_t offset, sample_struct_array_t * obj_val)
{
    if (!obj_val)
    {
        return false;
    }
    rb_buf_t buf = rb_nested_buf(rb_val, offset);
    if (buf.size < 1)
    {
        return false;
    }
    rb_size_t size = rb_get_array_count(&buf);
    if (size < 1)
    {
        memset(obj_val, 0, sizeof(sample_struct_array_t));
        return true;
    }

    *obj_val = rb_create_sample_struct_array(size);
    obj_val->size = size;

    rb_bool_t rc = true;
    rb_offset_t off = 0;
    rb_size_t i = 0;
    for (i = 0; i < size; ++i)
    {
        if (!rb_get_array_table_item(i, &buf, &off))
        {
            rc = false;
            break;
        }
        if (!rb_decode_sample_struct(&buf, off, obj_val->arr + i))
        {
            rc = false;
            break;
        }
    }
    if (!rc)
    {
        rb_dispose_sample_struct_array(obj_val);
    }
    return rc;
}

sample_struct_dict_t rb_create_sample_struct_dict(rb_size_t capacity)
{
    sample_struct_dict_t obj_val = { capacity, 0, 0 };
    if (capacity > 0)
    {
        rb_size_t len = capacity * sizeof(sample_struct_pair_t);
        obj_val.arr = (sample_struct_pair_t *) rb_malloc(len);
        memset(obj_val.arr, 0, len);
        rb_size_t i = 0;
        for (i = 0; i < capacity; ++i)
        {
            rb_init_string(&(obj_val.arr + i)->key);
            rb_init_sample_struct(&(obj_val.arr + i)->val);
        }
    }
    return obj_val;
}

sample_struct_pair_t * rb_sample_struct_dict_get_item(const sample_struct_dict_t * obj_val, const rb_str_t * key)
{
    if (!obj_val || !key || obj_val->size < 1 || obj_val->capacity < 1)
    {
        return NULL;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        sample_struct_pair_t * item = obj_val->arr + i;
        if (rb_eq_string(key, &item->key))
        {
            return item;
        }
    }
    return NULL;
}

rb_bool_t rb_sample_struct_dict_set_item(const rb_str_t * key, const sample_struct_t * val, sample_struct_dict_t * obj_val)
{
    if (!key || !val || !obj_val || !obj_val->arr || obj_val->size >= obj_val->capacity)
    {
        return false;
    }
    sample_struct_pair_t * it = rb_sample_struct_dict_get_item(obj_val, key);
    if (it)
    {
        rb_dispose_sample_struct(&it->val);
        return rb_set_sample_struct(val, &it->val);
    }
    it = obj_val->arr + obj_val->size;
    if (!rb_set_string(key, &it->key))
    {
        return false;
    }
    if (!rb_set_sample_struct(val, &it->val))
    {
        rb_dispose_string(&it->key);
        return false;
    }
    ++obj_val->size;
    return false;
}

void rb_init_sample_struct_dict(sample_struct_dict_t * obj_val)
{
    if (!obj_val || !obj_val->arr || obj_val->capacity < 1)
    {
        return;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->capacity; ++i)
    {
        sample_struct_pair_t * it = obj_val->arr + i;
        rb_init_string(&it->key);
        rb_init_sample_struct(&it->val);
    }
}

rb_bool_t rb_set_sample_struct_dict(const sample_struct_dict_t * src, sample_struct_dict_t * dst)
{
    if(!src || !src->arr || !dst)
    {
        return false;
    }
    if (src->size < 1)
    {
        memset(dst, 0, sizeof(sample_struct_dict_t));
        return true;
    }
    *dst = rb_create_sample_struct_dict(src->size);
    dst->size = src->size;
    rb_size_t i = 0;
    for (i = 0; i < dst->size; ++i)
    {
        sample_struct_pair_t * it_src = src->arr + i;
        sample_struct_pair_t * it_dst = dst->arr + i;
        if (!rb_set_string(&it_src->key, &it_dst->key))
        {
            rb_dispose_sample_struct_dict(dst);
            return false;
        }
        if (!rb_set_sample_struct(&it_src->val, &it_dst->val))
        {
            rb_dispose_sample_struct_dict(dst);
            return false;
        }
    }
    return true;
}

rb_bool_t rb_eq_sample_struct_dict(const sample_struct_dict_t * src, const sample_struct_dict_t * dst)
{
    if(!src || !dst)
    {
        return false;
    }
    if (!src->arr && !dst->arr)
    {
        return true;
    }
    if(!src->arr || !dst->arr || (src->size != dst->size))
    {
        return false;
    }
    rb_size_t i = 0;
    for (i = 0; i < src->size; ++i)
    {
        sample_struct_pair_t * it_src = src->arr + i;
        sample_struct_pair_t * it_dst = dst->arr + i;
        if (!rb_eq_string(&it_src->key, &it_dst->key))
        {
            return false;
        }
        if (!rb_eq_sample_struct(&it_src->val, &it_dst->val))
        {
            return false;
        }
    }
    return true;
}

void rb_dispose_sample_struct_dict(sample_struct_dict_t * obj_val)
{
    if (!obj_val || !obj_val->arr)
    {
        return;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        sample_struct_pair_t * it = obj_val->arr + i;
        rb_dispose_string(&it->key);
        rb_dispose_sample_struct(&it->val);
    }
    rb_free(obj_val->arr);
    memset(obj_val, 0, sizeof(sample_struct_dict_t));
}

rb_size_t rb_sizeof_sample_struct_dict(const sample_struct_dict_t * obj_val)
{
    rb_size_t size = sizeof(rb_size_t) + obj_val->size * sizeof(rb_size_t);
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        sample_struct_pair_t * it = obj_val->arr + i;
        size += rb_sizeof_string(&it->key);
        size += rb_sizeof_sample_struct(&it->val);
    }
    return size;
}

rb_bool_t rb_encode_sample_struct_dict(const sample_struct_dict_t * obj_val, rb_buf_t * rb_val)
{
    if (!obj_val || !obj_val->arr)
    {
        return false;
    }
    rb_buf_t buf = rb_nested_buf(rb_val, 0);
    if (buf.size < 1)
    {
        return false;
    }
    if (!rb_set_array_count(obj_val->size, &buf))
    {
        return false;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        if (!rb_set_array_table_item(i, buf.pos - buf.start, &buf))
        {
            return false;
        }
        sample_struct_pair_t * it = obj_val->arr + i;
        if (!rb_encode_string(&it->key, &buf))
        {
            return false;
        }
        if (!rb_encode_sample_struct(&it->val, &buf))
        {
            return false;
        }
    }
    rb_val->pos = buf.pos;
    return true;
}

rb_bool_t rb_decode_sample_struct_dict(const rb_buf_t * rb_val, rb_offset_t offset, sample_struct_dict_t * obj_val)
{
    if (!obj_val)
    {
        return false;
    }
    rb_buf_t buf = rb_nested_buf(rb_val, offset);
    if (buf.size < 1)
    {
        return false;
    }
    rb_size_t size = rb_get_array_count(&buf);
    if (size < 1)
    {
        memset(obj_val, 0, sizeof(sample_struct_dict_t));
        return true;
    }

    *obj_val = rb_create_sample_struct_dict(size);
    obj_val->size = size;

    rb_bool_t rc = true;
    rb_offset_t off = 0;
    rb_size_t i = 0;
    for (i = 0; i < size; ++i)
    {
        if (!rb_get_array_table_item(i, &buf, &off))
        {
            rc = false;
            break;
        }
        sample_struct_pair_t * it = obj_val->arr + i;
        if (!rb_decode_string(&buf, off, &it->key))
        {
            rc = false;
            break;
        }
        rb_offset_t delta = rb_sizeof_string(&it->key);
        if (!rb_decode_sample_struct(&buf, off + delta, &it->val))
        {
            rc = false;
            break;
        }
    }
    if (!rc)
    {
        rb_dispose_sample_struct_dict(obj_val);
    }
    return rc;
}

void rb_init_sample_object(sample_object_t * obj_val)
{
    if (!obj_val)
    {
        return;
    }
    memset(obj_val, 0, sizeof(sample_object_t));

    rb_init_sample_struct(&obj_val->obj);
    obj_val->id_obj = 0;
    obj_val->skip_obj = false;
    obj_val->rb_has_obj = false;

    rb_init_sample_struct_array(&obj_val->arr);
    obj_val->id_arr = 1;
    obj_val->skip_arr = false;
    obj_val->rb_has_arr = false;

    rb_init_sample_struct_dict(&obj_val->dict);
    obj_val->id_dict = 2;
    obj_val->skip_dict = false;
    obj_val->rb_has_dict = false;
}

rb_bool_t rb_set_sample_object(const sample_object_t * src, sample_object_t * dst)
{
    if (!src || !dst)
    {
        return false;
    }
    dst->id_obj = src->id_obj;
    dst->id_arr = src->id_arr;
    dst->id_dict = src->id_dict;
    do
    {
        if (!rb_set_sample_struct(&src->obj, &dst->obj)) break;
        if (!rb_set_sample_struct_array(&src->arr, &dst->arr)) break;
        if (!rb_set_sample_struct_dict(&src->dict, &dst->dict)) break;

        return true;
    } while (0);

    return false;
}

rb_bool_t rb_eq_sample_object(const sample_object_t * src, const sample_object_t * dst)
{
    if (!src || !dst)
    {
        return false;
    }
    do
    {
        if (!rb_eq_sample_struct(&src->obj, &dst->obj)) break;
        if (!rb_eq_sample_struct_array(&src->arr, &dst->arr)) break;
        if (!rb_eq_sample_struct_dict(&src->dict, &dst->dict)) break;

        return true;
    } while (0);

    return false;
}

void rb_dispose_sample_object(sample_object_t * obj_val)
{
    if (!obj_val)
    {
        return;
    }
    rb_dispose_sample_struct(&obj_val->obj);
    rb_dispose_sample_struct_array(&obj_val->arr);
    rb_dispose_sample_struct_dict(&obj_val->dict);
}

rb_field_size_t rb_fields_sample_object(const sample_object_t * obj_val)
{
    rb_field_size_t fields = 0;
    if (!obj_val->skip_obj) ++fields;
    if (!obj_val->skip_arr) ++fields;
    if (!obj_val->skip_dict) ++fields;
    return fields;
}

rb_size_t rb_sizeof_sample_object(const sample_object_t * obj_val)
{
    rb_field_size_t fields = 0;
    rb_size_t size = 0;
    if (!obj_val->skip_obj)
    {
        size += rb_sizeof_sample_struct(&obj_val->obj);
        ++fields;
    }
    if (!obj_val->skip_arr)
    {
        size += rb_sizeof_sample_struct_array(&obj_val->arr);
        ++fields;
    }
    if (!obj_val->skip_dict)
    {
        size += rb_sizeof_sample_struct_dict(&obj_val->dict);
        ++fields;
    }
    size += rb_seek_field_table_item(fields);
    size += sizeof(rb_buf_end_t);
    return size;
}

rb_bool_t rb_encode_sample_object(const sample_object_t * obj_val, rb_buf_t * rb_val)
{
    rb_buf_t buf = rb_nested_buf(rb_val, 0);
    if (buf.size < 1)
    {
        return false;
    }
    do
    {
        rb_field_size_t fields = rb_fields_sample_object(obj_val);
        rb_field_size_t index = 0;
        if (!rb_set_field_count(fields, &buf)) break;

        if (!obj_val->skip_obj)
        {
            if (!rb_set_field_table_item(index++, obj_val->id_obj, buf.pos - buf.start, &buf)) break;
            if (!rb_encode_sample_struct(&obj_val->obj, &buf)) break;
        }
        if (!obj_val->skip_arr)
        {
            if (!rb_set_field_table_item(index++, obj_val->id_arr, buf.pos - buf.start, &buf)) break;
            if (!rb_encode_sample_struct_array(&obj_val->arr, &buf)) break;
        }
        if (!obj_val->skip_dict)
        {
            if (!rb_set_field_table_item(index++, obj_val->id_dict, buf.pos - buf.start, &buf)) break;
            if (!rb_encode_sample_struct_dict(&obj_val->dict, &buf)) break;
        }

        if (!rb_set_buf_size(buf.pos - buf.start + sizeof(rb_buf_end_t), &buf)) break;
        if (!rb_encode_end(fields, &buf)) break;
        rb_val->pos = buf.pos;

        return true;
    } while (0);

    return false;
}

static rb_bool_t __decode_sample_object(
    const rb_field_table_item_t * item,
    const rb_buf_t * rb_val,
    sample_object_t * obj_val)
{
    if (item->id == obj_val->id_obj)
    {
        rb_bool_t rc = rb_decode_sample_struct(rb_val, item->offset, &obj_val->obj);
        if (rc)
        {
            obj_val->rb_has_obj = true;
        }
        return rc;
    }
    if (item->id == obj_val->id_arr)
    {
        rb_bool_t rc = rb_decode_sample_struct_array(rb_val, item->offset, &obj_val->arr);
        if (rc)
        {
            obj_val->rb_has_arr = true;
        }
        return rc;
    }
    if (item->id == obj_val->id_dict)
    {
        rb_bool_t rc = rb_decode_sample_struct_dict(rb_val, item->offset, &obj_val->dict);
        if (rc)
        {
            obj_val->rb_has_dict = true;
        }
        return rc;
    }
    return true;
}

rb_bool_t rb_decode_sample_object(const rb_buf_t * rb_val, rb_offset_t offset, sample_object_t * obj_val)
{
    if (!obj_val)
    {
        return false;
    }
    rb_buf_t buf = rb_nested_buf(rb_val, offset);
    if (buf.size < 1)
    {
        return false;
    }
    rb_field_table_head_t head = rb_get_field_table_head(&buf);
    if (head.fields < 1 || !rb_check_code(&buf, &head))
    {
        return false;
    }
    rb_field_table_item_t item = { 0, 0 };
    rb_field_size_t i = 0;
    for (i = 0; i < head.fields; ++i)
    {
        if (!rb_get_field_table_item(i, &buf, &item))
        {
            return false;
        }
        if (item.offset >= head.size)
        {
            return false;
        }
        if (item.offset > 0 && !__decode_sample_object(&item, &buf, obj_val))
        {
            return false;
        }
    }
    return true;
}

static rb_bool_t __dump_sample_object(const void * obj_val, rb_buf_t * buf)
{
    return rb_encode_sample_object((sample_object_t *) obj_val, buf);
}

rb_bool_t rb_dump_sample_object(const sample_object_t * obj_val, const char * path)
{
    if (!obj_val || !path)
    {
        return false;
    }
    rb_size_t size = rb_sizeof_sample_object(obj_val);
    if (size < 1)
    {
        return false;
    }
    return rb_dump_buf(__dump_sample_object, obj_val, size, path);
}

static rb_bool_t __load_sample_object(const rb_buf_t * buf, void * obj_val)
{
    return rb_decode_sample_object(buf, 0, (sample_object_t *) obj_val);
}

rb_bool_t rb_load_sample_object(const char * path, sample_object_t * obj_val)
{
    return rb_load_buf(path, __load_sample_object, obj_val);
}
