////////////////////////////////////////////////////////////////////////////////
// NOTE : Generated by rawbuf. It is NOT supposed to modify this file.
////////////////////////////////////////////////////////////////////////////////
#include "rawbuf.h"
#ifdef WIN32
#define true  1
#define false 0
#else
#include <stdbool.h>
#endif

void rb_init_bool(rb_bool_t * obj_val)
{
    if (obj_val)
    {
        *obj_val = 0;
    }
}

void rb_init_int8(int8_t * obj_val)
{
    if (obj_val)
    {
        *obj_val = 0;
    }
}

void rb_init_uint8(uint8_t * obj_val)
{
    if (obj_val)
    {
        *obj_val = 0;
    }
}

void rb_init_int16(int16_t * obj_val)
{
    if (obj_val)
    {
        *obj_val = 0;
    }
}

void rb_init_uint16(uint16_t * obj_val)
{
    if (obj_val)
    {
        *obj_val = 0;
    }
}

void rb_init_int32(int32_t * obj_val)
{
    if (obj_val)
    {
        *obj_val = 0;
    }
}

void rb_init_uint32(uint32_t * obj_val)
{
    if (obj_val)
    {
        *obj_val = 0;
    }
}

void rb_init_int64(int64_t * obj_val)
{
    if (obj_val)
    {
        *obj_val = 0;
    }
}

void rb_init_uint64(uint64_t * obj_val)
{
    if (obj_val)
    {
        *obj_val = 0;
    }
}

void rb_init_float(float * obj_val)
{
    if (obj_val)
    {
        *obj_val = 0.0;
    }
}

void rb_init_double(double * obj_val)
{
    if (obj_val)
    {
        *obj_val = 0.0;
    }
}

rb_bool_t rb_set_bool(const rb_bool_t * src, rb_bool_t * dst)
{
    if (!src || !dst)
    {
        return false;
    }
    *dst = *src;
    return true;
}

rb_bool_t rb_set_int8(const int8_t * src, int8_t * dst)
{
    if (!src || !dst)
    {
        return false;
    }
    *dst = *src;
    return true;
}

rb_bool_t rb_set_uint8(const uint8_t * src, uint8_t * dst)
{
    if (!src || !dst)
    {
        return false;
    }
    *dst = *src;
    return true;
}

rb_bool_t rb_set_int16(const int16_t * src, int16_t * dst)
{
    if (!src || !dst)
    {
        return false;
    }
    *dst = *src;
    return true;
}

rb_bool_t rb_set_uint16(const uint16_t * src, uint16_t * dst)
{
    if (!src || !dst)
    {
        return false;
    }
    *dst = *src;
    return true;
}

rb_bool_t rb_set_int32(const int32_t * src, int32_t * dst)
{
    if (!src || !dst)
    {
        return false;
    }
    *dst = *src;
    return true;
}

rb_bool_t rb_set_uint32(const uint32_t * src, uint32_t * dst)
{
    if (!src || !dst)
    {
        return false;
    }
    *dst = *src;
    return true;
}

rb_bool_t rb_set_int64(const int64_t * src, int64_t * dst)
{
    if (!src || !dst)
    {
        return false;
    }
    *dst = *src;
    return true;
}

rb_bool_t rb_set_uint64(const uint64_t * src, uint64_t * dst)
{
    if (!src || !dst)
    {
        return false;
    }
    *dst = *src;
    return true;
}

rb_bool_t rb_set_float(const float * src, float * dst)
{
    if (!src || !dst)
    {
        return false;
    }
    *dst = *src;
    return true;
}

rb_bool_t rb_set_double(const double * src, double * dst)
{
    if (!src || !dst)
    {
        return false;
    }
    *dst = *src;
    return true;
}

rb_bool_t rb_eq_bool(const rb_bool_t * src, const rb_bool_t * dst)
{
    if (!src || !dst)
    {
        return false;
    }
    return *src == *dst;
}

rb_bool_t rb_eq_int8(const int8_t * src, const int8_t * dst)
{
    if (!src || !dst)
    {
        return false;
    }
    return *src == *dst;
}

rb_bool_t rb_eq_uint8(const uint8_t * src, const uint8_t * dst)
{
    if (!src || !dst)
    {
        return false;
    }
    return *src == *dst;
}

rb_bool_t rb_eq_int16(const int16_t * src, const int16_t * dst)
{
    if (!src || !dst)
    {
        return false;
    }
    return *src == *dst;
}

rb_bool_t rb_eq_uint16(const uint16_t * src, const uint16_t * dst)
{
    if (!src || !dst)
    {
        return false;
    }
    return *src == *dst;
}

rb_bool_t rb_eq_int32(const int32_t * src, const int32_t * dst)
{
    if (!src || !dst)
    {
        return false;
    }
    return *src == *dst;
}

rb_bool_t rb_eq_uint32(const uint32_t * src, const uint32_t * dst)
{
    if (!src || !dst)
    {
        return false;
    }
    return *src == *dst;
}

rb_bool_t rb_eq_int64(const int64_t * src, const int64_t * dst)
{
    if (!src || !dst)
    {
        return false;
    }
    return *src == *dst;
}

rb_bool_t rb_eq_uint64(const uint64_t * src, const uint64_t * dst)
{
    if (!src || !dst)
    {
        return false;
    }
    return *src == *dst;
}

rb_bool_t rb_eq_float(const float * src, const float * dst)
{
    if (!src || !dst)
    {
        return false;
    }
    return *src == *dst;
}

rb_bool_t rb_eq_double(const double * src, const double * dst)
{
    if (!src || !dst)
    {
        return false;
    }
    return *src == *dst;
}

void rb_dispose_bool(rb_bool_t * obj_val)
{
    if (obj_val)
    {
        *obj_val = 0;
    }
}

void rb_dispose_int8(int8_t * obj_val)
{
    if (obj_val)
    {
        *obj_val = 0;
    }
}

void rb_dispose_uint8(uint8_t * obj_val)
{
    if (obj_val)
    {
        *obj_val = 0;
    }
}

void rb_dispose_int16(int16_t * obj_val)
{
    if (obj_val)
    {
        *obj_val = 0;
    }
}

void rb_dispose_uint16(uint16_t * obj_val)
{
    if (obj_val)
    {
        *obj_val = 0;
    }
}

void rb_dispose_int32(int32_t * obj_val)
{
    if (obj_val)
    {
        *obj_val = 0;
    }
}

void rb_dispose_uint32(uint32_t * obj_val)
{
    if (obj_val)
    {
        *obj_val = 0;
    }
}

void rb_dispose_int64(int64_t * obj_val)
{
    if (obj_val)
    {
        *obj_val = 0;
    }
}

void rb_dispose_uint64(uint64_t * obj_val)
{
    if (obj_val)
    {
        *obj_val = 0;
    }
}

void rb_dispose_float(float * obj_val)
{
    if (obj_val)
    {
        *obj_val = 0.0;
    }
}

void rb_dispose_double(double * obj_val)
{
    if (obj_val)
    {
        *obj_val = 0.0;
    }
}

rb_size_t rb_sizeof_bool(const rb_bool_t * obj_val)
{
    return sizeof(rb_bool_t);
}

rb_size_t rb_sizeof_int8(const int8_t * obj_val)
{
    return sizeof(int8_t);
}

rb_size_t rb_sizeof_uint8(const uint8_t * obj_val)
{
    return sizeof(uint8_t);
}

rb_size_t rb_sizeof_int16(const int16_t * obj_val)
{
    return sizeof(int16_t);
}

rb_size_t rb_sizeof_uint16(const uint16_t * obj_val)
{
    return sizeof(uint16_t);
}

rb_size_t rb_sizeof_int32(const int32_t * obj_val)
{
    return sizeof(int32_t);
}

rb_size_t rb_sizeof_uint32(const uint32_t * obj_val)
{
    return sizeof(uint32_t);
}

rb_size_t rb_sizeof_int64(const int64_t * obj_val)
{
    return sizeof(int64_t);
}

rb_size_t rb_sizeof_uint64(const uint64_t * obj_val)
{
    return sizeof(uint64_t);
}

rb_size_t rb_sizeof_float(const float * obj_val)
{
    return sizeof(float);
}

rb_size_t rb_sizeof_double(const double * obj_val)
{
    return sizeof(double);
}

rb_bool_t rb_encode_bool(const rb_bool_t * obj_val, rb_buf_t * rb_val)
{
    rb_size_t len = sizeof(rb_bool_t);
    if (!obj_val || !rb_encode_check(rb_val, len))
    {
        return false;
    }
    little_endian_copy(rb_val->pos, obj_val, len);
    rb_val->pos += len;
    return true;
}

rb_bool_t rb_encode_int8(const int8_t * obj_val, rb_buf_t * rb_val)
{
    rb_size_t len = sizeof(int8_t);
    if (!obj_val || !rb_encode_check(rb_val, len))
    {
        return false;
    }
    little_endian_copy(rb_val->pos, obj_val, len);
    rb_val->pos += len;
    return true;
}

rb_bool_t rb_encode_uint8(const uint8_t * obj_val, rb_buf_t * rb_val)
{
    rb_size_t len = sizeof(uint8_t);
    if (!obj_val || !rb_encode_check(rb_val, len))
    {
        return false;
    }
    little_endian_copy(rb_val->pos, obj_val, len);
    rb_val->pos += len;
    return true;
}

rb_bool_t rb_encode_int16(const int16_t * obj_val, rb_buf_t * rb_val)
{
    rb_size_t len = sizeof(int16_t);
    if (!obj_val || !rb_encode_check(rb_val, len))
    {
        return false;
    }
    little_endian_copy(rb_val->pos, obj_val, len);
    rb_val->pos += len;
    return true;
}

rb_bool_t rb_encode_uint16(const uint16_t * obj_val, rb_buf_t * rb_val)
{
    rb_size_t len = sizeof(uint16_t);
    if (!obj_val || !rb_encode_check(rb_val, len))
    {
        return false;
    }
    little_endian_copy(rb_val->pos, obj_val, len);
    rb_val->pos += len;
    return true;
}

rb_bool_t rb_encode_int32(const int32_t * obj_val, rb_buf_t * rb_val)
{
    rb_size_t len = sizeof(int32_t);
    if (!obj_val || !rb_encode_check(rb_val, len))
    {
        return false;
    }
    little_endian_copy(rb_val->pos, obj_val, len);
    rb_val->pos += len;
    return true;
}

rb_bool_t rb_encode_uint32(const uint32_t * obj_val, rb_buf_t * rb_val)
{
    rb_size_t len = sizeof(uint32_t);
    if (!obj_val || !rb_encode_check(rb_val, len))
    {
        return false;
    }
    little_endian_copy(rb_val->pos, obj_val, len);
    rb_val->pos += len;
    return true;
}

rb_bool_t rb_encode_int64(const int64_t * obj_val, rb_buf_t * rb_val)
{
    rb_size_t len = sizeof(int64_t);
    if (!obj_val || !rb_encode_check(rb_val, len))
    {
        return false;
    }
    little_endian_copy(rb_val->pos, obj_val, len);
    rb_val->pos += len;
    return true;
}

rb_bool_t rb_encode_uint64(const uint64_t * obj_val, rb_buf_t * rb_val)
{
    rb_size_t len = sizeof(uint64_t);
    if (!obj_val || !rb_encode_check(rb_val, len))
    {
        return false;
    }
    little_endian_copy(rb_val->pos, obj_val, len);
    rb_val->pos += len;
    return true;
}

rb_bool_t rb_encode_float(const float * obj_val, rb_buf_t * rb_val)
{
    rb_size_t len = sizeof(float);
    if (!obj_val || !rb_encode_check(rb_val, len))
    {
        return false;
    }
    little_endian_copy(rb_val->pos, obj_val, len);
    rb_val->pos += len;
    return true;
}

rb_bool_t rb_encode_double(const double * obj_val, rb_buf_t * rb_val)
{
    rb_size_t len = sizeof(double);
    if (!obj_val || !rb_encode_check(rb_val, len))
    {
        return false;
    }
    little_endian_copy(rb_val->pos, obj_val, len);
    rb_val->pos += len;
    return true;
}

rb_bool_t rb_decode_bool(const rb_buf_t * rb_val, rb_offset_t offset, rb_bool_t * obj_val)
{
    rb_size_t len = sizeof(rb_bool_t);
    if (!obj_val || !rb_decode_check(rb_val, offset, len))
    {
        return false;
    }
    little_endian_copy(obj_val, rb_val->start + offset, len);
    return true;
}

rb_bool_t rb_decode_int8(const rb_buf_t * rb_val, rb_offset_t offset, int8_t * obj_val)
{
    rb_size_t len = sizeof(int8_t);
    if (!obj_val || !rb_decode_check(rb_val, offset, len))
    {
        return false;
    }
    little_endian_copy(obj_val, rb_val->start + offset, len);
    return true;
}

rb_bool_t rb_decode_uint8(const rb_buf_t * rb_val, rb_offset_t offset, uint8_t * obj_val)
{
    rb_size_t len = sizeof(uint8_t);
    if (!obj_val || !rb_decode_check(rb_val, offset, len))
    {
        return false;
    }
    little_endian_copy(obj_val, rb_val->start + offset, len);
    return true;
}

rb_bool_t rb_decode_int16(const rb_buf_t * rb_val, rb_offset_t offset, int16_t * obj_val)
{
    rb_size_t len = sizeof(int16_t);
    if (!obj_val || !rb_decode_check(rb_val, offset, len))
    {
        return false;
    }
    little_endian_copy(obj_val, rb_val->start + offset, len);
    return true;
}

rb_bool_t rb_decode_uint16(const rb_buf_t * rb_val, rb_offset_t offset, uint16_t * obj_val)
{
    rb_size_t len = sizeof(uint16_t);
    if (!obj_val || !rb_decode_check(rb_val, offset, len))
    {
        return false;
    }
    little_endian_copy(obj_val, rb_val->start + offset, len);
    return true;
}

rb_bool_t rb_decode_int32(const rb_buf_t * rb_val, rb_offset_t offset, int32_t * obj_val)
{
    rb_size_t len = sizeof(int32_t);
    if (!obj_val || !rb_decode_check(rb_val, offset, len))
    {
        return false;
    }
    little_endian_copy(obj_val, rb_val->start + offset, len);
    return true;
}

rb_bool_t rb_decode_uint32(const rb_buf_t * rb_val, rb_offset_t offset, uint32_t * obj_val)
{
    rb_size_t len = sizeof(uint32_t);
    if (!obj_val || !rb_decode_check(rb_val, offset, len))
    {
        return false;
    }
    little_endian_copy(obj_val, rb_val->start + offset, len);
    return true;
}

rb_bool_t rb_decode_int64(const rb_buf_t * rb_val, rb_offset_t offset, int64_t * obj_val)
{
    rb_size_t len = sizeof(int64_t);
    if (!obj_val || !rb_decode_check(rb_val, offset, len))
    {
        return false;
    }
    little_endian_copy(obj_val, rb_val->start + offset, len);
    return true;
}

rb_bool_t rb_decode_uint64(const rb_buf_t * rb_val, rb_offset_t offset, uint64_t * obj_val)
{
    rb_size_t len = sizeof(uint64_t);
    if (!obj_val || !rb_decode_check(rb_val, offset, len))
    {
        return false;
    }
    little_endian_copy(obj_val, rb_val->start + offset, len);
    return true;
}

rb_bool_t rb_decode_float(const rb_buf_t * rb_val, rb_offset_t offset, float * obj_val)
{
    rb_size_t len = sizeof(float);
    if (!obj_val || !rb_decode_check(rb_val, offset, len))
    {
        return false;
    }
    little_endian_copy(obj_val, rb_val->start + offset, len);
    return true;
}

rb_bool_t rb_decode_double(const rb_buf_t * rb_val, rb_offset_t offset, double * obj_val)
{
    rb_size_t len = sizeof(double);
    if (!obj_val || !rb_decode_check(rb_val, offset, len))
    {
        return false;
    }
    little_endian_copy(obj_val, rb_val->start + offset, len);
    return true;
}

bool_array_t rb_create_bool_array(rb_size_t capacity)
{
    bool_array_t obj_val = { capacity, 0, 0 };
    if (capacity > 0)
    {
        rb_size_t len = capacity * sizeof(rb_bool_t);
        obj_val.arr = (rb_bool_t *) rb_malloc(len);
        memset(obj_val.arr, 0, len);
        rb_size_t i = 0;
        for (i = 0; i < capacity; ++i)
        {
            rb_init_bool(obj_val.arr + i);
        }
    }
    return obj_val;
}

rb_bool_t rb_append_to_bool_array(const rb_bool_t * item, bool_array_t * obj_val)
{
    if (!item || !obj_val || !obj_val->arr || obj_val->size >= obj_val->capacity)
    {
        return false;
    }
    rb_bool_t * dst = obj_val->arr + obj_val->size;
    if (rb_set_bool(item, dst))
    {
        ++obj_val->size;
        return true;
    }
    return false;
}

void rb_init_bool_array(bool_array_t * obj_val)
{
    if (!obj_val || !obj_val->arr || obj_val->capacity < 1)
    {
        return;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->capacity; ++i)
    {
        rb_init_bool(obj_val->arr + i);
    }
}

rb_bool_t rb_set_bool_array(const bool_array_t * src, bool_array_t * dst)
{
    if(!src || !src->arr || !dst)
    {
        return false;
    }
    if (src->size < 1)
    {
        memset(dst, 0, sizeof(bool_array_t));
        return true;
    }
    *dst = rb_create_bool_array(src->size);
    dst->size = src->size;
    rb_size_t i = 0;
    for (i = 0; i < dst->size; ++i)
    {
        if (!rb_set_bool(src->arr + i, dst->arr + i))
        {
            rb_dispose_bool_array(dst);
            return false;
        }
    }
    return true;
}

rb_bool_t rb_eq_bool_array(const bool_array_t * src, const bool_array_t * dst)
{
    if(!src || !dst)
    {
        return false;
    }
    if (!src->arr && !dst->arr)
    {
        return true;
    }
    if(!src->arr || !dst->arr || (src->size != dst->size))
    {
        return false;
    }
    rb_size_t i = 0;
    for (i = 0; i < src->size; ++i)
    {
        if (!rb_eq_bool(src->arr + i, dst->arr + i))
        {
            return false;
        }
    }
    return true;
}

void rb_dispose_bool_array(bool_array_t * obj_val)
{
    if (!obj_val || !obj_val->arr)
    {
        return;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        rb_dispose_bool(obj_val->arr + i);
    }
    rb_free(obj_val->arr);
    memset(obj_val, 0, sizeof(bool_array_t));
}

rb_size_t rb_sizeof_bool_array(const bool_array_t * obj_val)
{
    rb_size_t size = sizeof(rb_size_t) + obj_val->size * sizeof(rb_size_t);
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        size += rb_sizeof_bool(obj_val->arr + i);
    }
    return size;
}

rb_bool_t rb_encode_bool_array(const bool_array_t * obj_val, rb_buf_t * rb_val)
{
    if (!obj_val || !obj_val->arr)
    {
        return false;
    }
    rb_buf_t buf = rb_nested_buf(rb_val, 0);
    if (buf.size < 1)
    {
        return false;
    }
    if (!rb_set_array_count(obj_val->size, &buf))
    {
        return false;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        if (!rb_set_array_table_item(i, buf.pos - buf.start, &buf))
        {
            return false;
        }
        if (!rb_encode_bool(obj_val->arr + i, &buf))
        {
            return false;
        }
    }
    rb_val->pos = buf.pos;
    return true;
}

rb_bool_t rb_decode_bool_array(const rb_buf_t * rb_val, rb_offset_t offset, bool_array_t * obj_val)
{
    if (!obj_val)
    {
        return false;
    }
    rb_buf_t buf = rb_nested_buf(rb_val, offset);
    if (buf.size < 1)
    {
        return false;
    }
    rb_size_t size = rb_get_array_count(&buf);
    if (size < 1)
    {
        memset(obj_val, 0, sizeof(bool_array_t));
        return true;
    }

    *obj_val = rb_create_bool_array(size);
    obj_val->size = size;

    rb_bool_t rc = true;
    rb_offset_t off = 0;
    rb_size_t i = 0;
    for (i = 0; i < size; ++i)
    {
        if (!rb_get_array_table_item(i, &buf, &off))
        {
            rc = false;
            break;
        }
        if (!rb_decode_bool(&buf, off, obj_val->arr + i))
        {
            rc = false;
            break;
        }
    }
    if (!rc)
    {
        rb_dispose_bool_array(obj_val);
    }
    return rc;
}

int8_array_t rb_create_int8_array(rb_size_t capacity)
{
    int8_array_t obj_val = { capacity, 0, 0 };
    if (capacity > 0)
    {
        rb_size_t len = capacity * sizeof(int8_t);
        obj_val.arr = (int8_t *) rb_malloc(len);
        memset(obj_val.arr, 0, len);
        rb_size_t i = 0;
        for (i = 0; i < capacity; ++i)
        {
            rb_init_int8(obj_val.arr + i);
        }
    }
    return obj_val;
}

rb_bool_t rb_append_to_int8_array(const int8_t * item, int8_array_t * obj_val)
{
    if (!item || !obj_val || !obj_val->arr || obj_val->size >= obj_val->capacity)
    {
        return false;
    }
    int8_t * dst = obj_val->arr + obj_val->size;
    if (rb_set_int8(item, dst))
    {
        ++obj_val->size;
        return true;
    }
    return false;
}

void rb_init_int8_array(int8_array_t * obj_val)
{
    if (!obj_val || !obj_val->arr || obj_val->capacity < 1)
    {
        return;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->capacity; ++i)
    {
        rb_init_int8(obj_val->arr + i);
    }
}

rb_bool_t rb_set_int8_array(const int8_array_t * src, int8_array_t * dst)
{
    if(!src || !src->arr || !dst)
    {
        return false;
    }
    if (src->size < 1)
    {
        memset(dst, 0, sizeof(int8_array_t));
        return true;
    }
    *dst = rb_create_int8_array(src->size);
    dst->size = src->size;
    rb_size_t i = 0;
    for (i = 0; i < dst->size; ++i)
    {
        if (!rb_set_int8(src->arr + i, dst->arr + i))
        {
            rb_dispose_int8_array(dst);
            return false;
        }
    }
    return true;
}

rb_bool_t rb_eq_int8_array(const int8_array_t * src, const int8_array_t * dst)
{
    if(!src || !dst)
    {
        return false;
    }
    if (!src->arr && !dst->arr)
    {
        return true;
    }
    if(!src->arr || !dst->arr || (src->size != dst->size))
    {
        return false;
    }
    rb_size_t i = 0;
    for (i = 0; i < src->size; ++i)
    {
        if (!rb_eq_int8(src->arr + i, dst->arr + i))
        {
            return false;
        }
    }
    return true;
}

void rb_dispose_int8_array(int8_array_t * obj_val)
{
    if (!obj_val || !obj_val->arr)
    {
        return;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        rb_dispose_int8(obj_val->arr + i);
    }
    rb_free(obj_val->arr);
    memset(obj_val, 0, sizeof(int8_array_t));
}

rb_size_t rb_sizeof_int8_array(const int8_array_t * obj_val)
{
    rb_size_t size = sizeof(rb_size_t) + obj_val->size * sizeof(rb_size_t);
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        size += rb_sizeof_int8(obj_val->arr + i);
    }
    return size;
}

rb_bool_t rb_encode_int8_array(const int8_array_t * obj_val, rb_buf_t * rb_val)
{
    if (!obj_val || !obj_val->arr)
    {
        return false;
    }
    rb_buf_t buf = rb_nested_buf(rb_val, 0);
    if (buf.size < 1)
    {
        return false;
    }
    if (!rb_set_array_count(obj_val->size, &buf))
    {
        return false;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        if (!rb_set_array_table_item(i, buf.pos - buf.start, &buf))
        {
            return false;
        }
        if (!rb_encode_int8(obj_val->arr + i, &buf))
        {
            return false;
        }
    }
    rb_val->pos = buf.pos;
    return true;
}

rb_bool_t rb_decode_int8_array(const rb_buf_t * rb_val, rb_offset_t offset, int8_array_t * obj_val)
{
    if (!obj_val)
    {
        return false;
    }
    rb_buf_t buf = rb_nested_buf(rb_val, offset);
    if (buf.size < 1)
    {
        return false;
    }
    rb_size_t size = rb_get_array_count(&buf);
    if (size < 1)
    {
        memset(obj_val, 0, sizeof(int8_array_t));
        return true;
    }

    *obj_val = rb_create_int8_array(size);
    obj_val->size = size;

    rb_bool_t rc = true;
    rb_offset_t off = 0;
    rb_size_t i = 0;
    for (i = 0; i < size; ++i)
    {
        if (!rb_get_array_table_item(i, &buf, &off))
        {
            rc = false;
            break;
        }
        if (!rb_decode_int8(&buf, off, obj_val->arr + i))
        {
            rc = false;
            break;
        }
    }
    if (!rc)
    {
        rb_dispose_int8_array(obj_val);
    }
    return rc;
}

uint8_array_t rb_create_uint8_array(rb_size_t capacity)
{
    uint8_array_t obj_val = { capacity, 0, 0 };
    if (capacity > 0)
    {
        rb_size_t len = capacity * sizeof(uint8_t);
        obj_val.arr = (uint8_t *) rb_malloc(len);
        memset(obj_val.arr, 0, len);
        rb_size_t i = 0;
        for (i = 0; i < capacity; ++i)
        {
            rb_init_uint8(obj_val.arr + i);
        }
    }
    return obj_val;
}

rb_bool_t rb_append_to_uint8_array(const uint8_t * item, uint8_array_t * obj_val)
{
    if (!item || !obj_val || !obj_val->arr || obj_val->size >= obj_val->capacity)
    {
        return false;
    }
    uint8_t * dst = obj_val->arr + obj_val->size;
    if (rb_set_uint8(item, dst))
    {
        ++obj_val->size;
        return true;
    }
    return false;
}

void rb_init_uint8_array(uint8_array_t * obj_val)
{
    if (!obj_val || !obj_val->arr || obj_val->capacity < 1)
    {
        return;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->capacity; ++i)
    {
        rb_init_uint8(obj_val->arr + i);
    }
}

rb_bool_t rb_set_uint8_array(const uint8_array_t * src, uint8_array_t * dst)
{
    if(!src || !src->arr || !dst)
    {
        return false;
    }
    if (src->size < 1)
    {
        memset(dst, 0, sizeof(uint8_array_t));
        return true;
    }
    *dst = rb_create_uint8_array(src->size);
    dst->size = src->size;
    rb_size_t i = 0;
    for (i = 0; i < dst->size; ++i)
    {
        if (!rb_set_uint8(src->arr + i, dst->arr + i))
        {
            rb_dispose_uint8_array(dst);
            return false;
        }
    }
    return true;
}

rb_bool_t rb_eq_uint8_array(const uint8_array_t * src, const uint8_array_t * dst)
{
    if(!src || !dst)
    {
        return false;
    }
    if (!src->arr && !dst->arr)
    {
        return true;
    }
    if(!src->arr || !dst->arr || (src->size != dst->size))
    {
        return false;
    }
    rb_size_t i = 0;
    for (i = 0; i < src->size; ++i)
    {
        if (!rb_eq_uint8(src->arr + i, dst->arr + i))
        {
            return false;
        }
    }
    return true;
}

void rb_dispose_uint8_array(uint8_array_t * obj_val)
{
    if (!obj_val || !obj_val->arr)
    {
        return;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        rb_dispose_uint8(obj_val->arr + i);
    }
    rb_free(obj_val->arr);
    memset(obj_val, 0, sizeof(uint8_array_t));
}

rb_size_t rb_sizeof_uint8_array(const uint8_array_t * obj_val)
{
    rb_size_t size = sizeof(rb_size_t) + obj_val->size * sizeof(rb_size_t);
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        size += rb_sizeof_uint8(obj_val->arr + i);
    }
    return size;
}

rb_bool_t rb_encode_uint8_array(const uint8_array_t * obj_val, rb_buf_t * rb_val)
{
    if (!obj_val || !obj_val->arr)
    {
        return false;
    }
    rb_buf_t buf = rb_nested_buf(rb_val, 0);
    if (buf.size < 1)
    {
        return false;
    }
    if (!rb_set_array_count(obj_val->size, &buf))
    {
        return false;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        if (!rb_set_array_table_item(i, buf.pos - buf.start, &buf))
        {
            return false;
        }
        if (!rb_encode_uint8(obj_val->arr + i, &buf))
        {
            return false;
        }
    }
    rb_val->pos = buf.pos;
    return true;
}

rb_bool_t rb_decode_uint8_array(const rb_buf_t * rb_val, rb_offset_t offset, uint8_array_t * obj_val)
{
    if (!obj_val)
    {
        return false;
    }
    rb_buf_t buf = rb_nested_buf(rb_val, offset);
    if (buf.size < 1)
    {
        return false;
    }
    rb_size_t size = rb_get_array_count(&buf);
    if (size < 1)
    {
        memset(obj_val, 0, sizeof(uint8_array_t));
        return true;
    }

    *obj_val = rb_create_uint8_array(size);
    obj_val->size = size;

    rb_bool_t rc = true;
    rb_offset_t off = 0;
    rb_size_t i = 0;
    for (i = 0; i < size; ++i)
    {
        if (!rb_get_array_table_item(i, &buf, &off))
        {
            rc = false;
            break;
        }
        if (!rb_decode_uint8(&buf, off, obj_val->arr + i))
        {
            rc = false;
            break;
        }
    }
    if (!rc)
    {
        rb_dispose_uint8_array(obj_val);
    }
    return rc;
}

int16_array_t rb_create_int16_array(rb_size_t capacity)
{
    int16_array_t obj_val = { capacity, 0, 0 };
    if (capacity > 0)
    {
        rb_size_t len = capacity * sizeof(int16_t);
        obj_val.arr = (int16_t *) rb_malloc(len);
        memset(obj_val.arr, 0, len);
        rb_size_t i = 0;
        for (i = 0; i < capacity; ++i)
        {
            rb_init_int16(obj_val.arr + i);
        }
    }
    return obj_val;
}

rb_bool_t rb_append_to_int16_array(const int16_t * item, int16_array_t * obj_val)
{
    if (!item || !obj_val || !obj_val->arr || obj_val->size >= obj_val->capacity)
    {
        return false;
    }
    int16_t * dst = obj_val->arr + obj_val->size;
    if (rb_set_int16(item, dst))
    {
        ++obj_val->size;
        return true;
    }
    return false;
}

void rb_init_int16_array(int16_array_t * obj_val)
{
    if (!obj_val || !obj_val->arr || obj_val->capacity < 1)
    {
        return;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->capacity; ++i)
    {
        rb_init_int16(obj_val->arr + i);
    }
}

rb_bool_t rb_set_int16_array(const int16_array_t * src, int16_array_t * dst)
{
    if(!src || !src->arr || !dst)
    {
        return false;
    }
    if (src->size < 1)
    {
        memset(dst, 0, sizeof(int16_array_t));
        return true;
    }
    *dst = rb_create_int16_array(src->size);
    dst->size = src->size;
    rb_size_t i = 0;
    for (i = 0; i < dst->size; ++i)
    {
        if (!rb_set_int16(src->arr + i, dst->arr + i))
        {
            rb_dispose_int16_array(dst);
            return false;
        }
    }
    return true;
}

rb_bool_t rb_eq_int16_array(const int16_array_t * src, const int16_array_t * dst)
{
    if(!src || !dst)
    {
        return false;
    }
    if (!src->arr && !dst->arr)
    {
        return true;
    }
    if(!src->arr || !dst->arr || (src->size != dst->size))
    {
        return false;
    }
    rb_size_t i = 0;
    for (i = 0; i < src->size; ++i)
    {
        if (!rb_eq_int16(src->arr + i, dst->arr + i))
        {
            return false;
        }
    }
    return true;
}

void rb_dispose_int16_array(int16_array_t * obj_val)
{
    if (!obj_val || !obj_val->arr)
    {
        return;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        rb_dispose_int16(obj_val->arr + i);
    }
    rb_free(obj_val->arr);
    memset(obj_val, 0, sizeof(int16_array_t));
}

rb_size_t rb_sizeof_int16_array(const int16_array_t * obj_val)
{
    rb_size_t size = sizeof(rb_size_t) + obj_val->size * sizeof(rb_size_t);
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        size += rb_sizeof_int16(obj_val->arr + i);
    }
    return size;
}

rb_bool_t rb_encode_int16_array(const int16_array_t * obj_val, rb_buf_t * rb_val)
{
    if (!obj_val || !obj_val->arr)
    {
        return false;
    }
    rb_buf_t buf = rb_nested_buf(rb_val, 0);
    if (buf.size < 1)
    {
        return false;
    }
    if (!rb_set_array_count(obj_val->size, &buf))
    {
        return false;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        if (!rb_set_array_table_item(i, buf.pos - buf.start, &buf))
        {
            return false;
        }
        if (!rb_encode_int16(obj_val->arr + i, &buf))
        {
            return false;
        }
    }
    rb_val->pos = buf.pos;
    return true;
}

rb_bool_t rb_decode_int16_array(const rb_buf_t * rb_val, rb_offset_t offset, int16_array_t * obj_val)
{
    if (!obj_val)
    {
        return false;
    }
    rb_buf_t buf = rb_nested_buf(rb_val, offset);
    if (buf.size < 1)
    {
        return false;
    }
    rb_size_t size = rb_get_array_count(&buf);
    if (size < 1)
    {
        memset(obj_val, 0, sizeof(int16_array_t));
        return true;
    }

    *obj_val = rb_create_int16_array(size);
    obj_val->size = size;

    rb_bool_t rc = true;
    rb_offset_t off = 0;
    rb_size_t i = 0;
    for (i = 0; i < size; ++i)
    {
        if (!rb_get_array_table_item(i, &buf, &off))
        {
            rc = false;
            break;
        }
        if (!rb_decode_int16(&buf, off, obj_val->arr + i))
        {
            rc = false;
            break;
        }
    }
    if (!rc)
    {
        rb_dispose_int16_array(obj_val);
    }
    return rc;
}

uint16_array_t rb_create_uint16_array(rb_size_t capacity)
{
    uint16_array_t obj_val = { capacity, 0, 0 };
    if (capacity > 0)
    {
        rb_size_t len = capacity * sizeof(uint16_t);
        obj_val.arr = (uint16_t *) rb_malloc(len);
        memset(obj_val.arr, 0, len);
        rb_size_t i = 0;
        for (i = 0; i < capacity; ++i)
        {
            rb_init_uint16(obj_val.arr + i);
        }
    }
    return obj_val;
}

rb_bool_t rb_append_to_uint16_array(const uint16_t * item, uint16_array_t * obj_val)
{
    if (!item || !obj_val || !obj_val->arr || obj_val->size >= obj_val->capacity)
    {
        return false;
    }
    uint16_t * dst = obj_val->arr + obj_val->size;
    if (rb_set_uint16(item, dst))
    {
        ++obj_val->size;
        return true;
    }
    return false;
}

void rb_init_uint16_array(uint16_array_t * obj_val)
{
    if (!obj_val || !obj_val->arr || obj_val->capacity < 1)
    {
        return;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->capacity; ++i)
    {
        rb_init_uint16(obj_val->arr + i);
    }
}

rb_bool_t rb_set_uint16_array(const uint16_array_t * src, uint16_array_t * dst)
{
    if(!src || !src->arr || !dst)
    {
        return false;
    }
    if (src->size < 1)
    {
        memset(dst, 0, sizeof(uint16_array_t));
        return true;
    }
    *dst = rb_create_uint16_array(src->size);
    dst->size = src->size;
    rb_size_t i = 0;
    for (i = 0; i < dst->size; ++i)
    {
        if (!rb_set_uint16(src->arr + i, dst->arr + i))
        {
            rb_dispose_uint16_array(dst);
            return false;
        }
    }
    return true;
}

rb_bool_t rb_eq_uint16_array(const uint16_array_t * src, const uint16_array_t * dst)
{
    if(!src || !dst)
    {
        return false;
    }
    if (!src->arr && !dst->arr)
    {
        return true;
    }
    if(!src->arr || !dst->arr || (src->size != dst->size))
    {
        return false;
    }
    rb_size_t i = 0;
    for (i = 0; i < src->size; ++i)
    {
        if (!rb_eq_uint16(src->arr + i, dst->arr + i))
        {
            return false;
        }
    }
    return true;
}

void rb_dispose_uint16_array(uint16_array_t * obj_val)
{
    if (!obj_val || !obj_val->arr)
    {
        return;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        rb_dispose_uint16(obj_val->arr + i);
    }
    rb_free(obj_val->arr);
    memset(obj_val, 0, sizeof(uint16_array_t));
}

rb_size_t rb_sizeof_uint16_array(const uint16_array_t * obj_val)
{
    rb_size_t size = sizeof(rb_size_t) + obj_val->size * sizeof(rb_size_t);
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        size += rb_sizeof_uint16(obj_val->arr + i);
    }
    return size;
}

rb_bool_t rb_encode_uint16_array(const uint16_array_t * obj_val, rb_buf_t * rb_val)
{
    if (!obj_val || !obj_val->arr)
    {
        return false;
    }
    rb_buf_t buf = rb_nested_buf(rb_val, 0);
    if (buf.size < 1)
    {
        return false;
    }
    if (!rb_set_array_count(obj_val->size, &buf))
    {
        return false;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        if (!rb_set_array_table_item(i, buf.pos - buf.start, &buf))
        {
            return false;
        }
        if (!rb_encode_uint16(obj_val->arr + i, &buf))
        {
            return false;
        }
    }
    rb_val->pos = buf.pos;
    return true;
}

rb_bool_t rb_decode_uint16_array(const rb_buf_t * rb_val, rb_offset_t offset, uint16_array_t * obj_val)
{
    if (!obj_val)
    {
        return false;
    }
    rb_buf_t buf = rb_nested_buf(rb_val, offset);
    if (buf.size < 1)
    {
        return false;
    }
    rb_size_t size = rb_get_array_count(&buf);
    if (size < 1)
    {
        memset(obj_val, 0, sizeof(uint16_array_t));
        return true;
    }

    *obj_val = rb_create_uint16_array(size);
    obj_val->size = size;

    rb_bool_t rc = true;
    rb_offset_t off = 0;
    rb_size_t i = 0;
    for (i = 0; i < size; ++i)
    {
        if (!rb_get_array_table_item(i, &buf, &off))
        {
            rc = false;
            break;
        }
        if (!rb_decode_uint16(&buf, off, obj_val->arr + i))
        {
            rc = false;
            break;
        }
    }
    if (!rc)
    {
        rb_dispose_uint16_array(obj_val);
    }
    return rc;
}

int32_array_t rb_create_int32_array(rb_size_t capacity)
{
    int32_array_t obj_val = { capacity, 0, 0 };
    if (capacity > 0)
    {
        rb_size_t len = capacity * sizeof(int32_t);
        obj_val.arr = (int32_t *) rb_malloc(len);
        memset(obj_val.arr, 0, len);
        rb_size_t i = 0;
        for (i = 0; i < capacity; ++i)
        {
            rb_init_int32(obj_val.arr + i);
        }
    }
    return obj_val;
}

rb_bool_t rb_append_to_int32_array(const int32_t * item, int32_array_t * obj_val)
{
    if (!item || !obj_val || !obj_val->arr || obj_val->size >= obj_val->capacity)
    {
        return false;
    }
    int32_t * dst = obj_val->arr + obj_val->size;
    if (rb_set_int32(item, dst))
    {
        ++obj_val->size;
        return true;
    }
    return false;
}

void rb_init_int32_array(int32_array_t * obj_val)
{
    if (!obj_val || !obj_val->arr || obj_val->capacity < 1)
    {
        return;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->capacity; ++i)
    {
        rb_init_int32(obj_val->arr + i);
    }
}

rb_bool_t rb_set_int32_array(const int32_array_t * src, int32_array_t * dst)
{
    if(!src || !src->arr || !dst)
    {
        return false;
    }
    if (src->size < 1)
    {
        memset(dst, 0, sizeof(int32_array_t));
        return true;
    }
    *dst = rb_create_int32_array(src->size);
    dst->size = src->size;
    rb_size_t i = 0;
    for (i = 0; i < dst->size; ++i)
    {
        if (!rb_set_int32(src->arr + i, dst->arr + i))
        {
            rb_dispose_int32_array(dst);
            return false;
        }
    }
    return true;
}

rb_bool_t rb_eq_int32_array(const int32_array_t * src, const int32_array_t * dst)
{
    if(!src || !dst)
    {
        return false;
    }
    if (!src->arr && !dst->arr)
    {
        return true;
    }
    if(!src->arr || !dst->arr || (src->size != dst->size))
    {
        return false;
    }
    rb_size_t i = 0;
    for (i = 0; i < src->size; ++i)
    {
        if (!rb_eq_int32(src->arr + i, dst->arr + i))
        {
            return false;
        }
    }
    return true;
}

void rb_dispose_int32_array(int32_array_t * obj_val)
{
    if (!obj_val || !obj_val->arr)
    {
        return;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        rb_dispose_int32(obj_val->arr + i);
    }
    rb_free(obj_val->arr);
    memset(obj_val, 0, sizeof(int32_array_t));
}

rb_size_t rb_sizeof_int32_array(const int32_array_t * obj_val)
{
    rb_size_t size = sizeof(rb_size_t) + obj_val->size * sizeof(rb_size_t);
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        size += rb_sizeof_int32(obj_val->arr + i);
    }
    return size;
}

rb_bool_t rb_encode_int32_array(const int32_array_t * obj_val, rb_buf_t * rb_val)
{
    if (!obj_val || !obj_val->arr)
    {
        return false;
    }
    rb_buf_t buf = rb_nested_buf(rb_val, 0);
    if (buf.size < 1)
    {
        return false;
    }
    if (!rb_set_array_count(obj_val->size, &buf))
    {
        return false;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        if (!rb_set_array_table_item(i, buf.pos - buf.start, &buf))
        {
            return false;
        }
        if (!rb_encode_int32(obj_val->arr + i, &buf))
        {
            return false;
        }
    }
    rb_val->pos = buf.pos;
    return true;
}

rb_bool_t rb_decode_int32_array(const rb_buf_t * rb_val, rb_offset_t offset, int32_array_t * obj_val)
{
    if (!obj_val)
    {
        return false;
    }
    rb_buf_t buf = rb_nested_buf(rb_val, offset);
    if (buf.size < 1)
    {
        return false;
    }
    rb_size_t size = rb_get_array_count(&buf);
    if (size < 1)
    {
        memset(obj_val, 0, sizeof(int32_array_t));
        return true;
    }

    *obj_val = rb_create_int32_array(size);
    obj_val->size = size;

    rb_bool_t rc = true;
    rb_offset_t off = 0;
    rb_size_t i = 0;
    for (i = 0; i < size; ++i)
    {
        if (!rb_get_array_table_item(i, &buf, &off))
        {
            rc = false;
            break;
        }
        if (!rb_decode_int32(&buf, off, obj_val->arr + i))
        {
            rc = false;
            break;
        }
    }
    if (!rc)
    {
        rb_dispose_int32_array(obj_val);
    }
    return rc;
}

uint32_array_t rb_create_uint32_array(rb_size_t capacity)
{
    uint32_array_t obj_val = { capacity, 0, 0 };
    if (capacity > 0)
    {
        rb_size_t len = capacity * sizeof(uint32_t);
        obj_val.arr = (uint32_t *) rb_malloc(len);
        memset(obj_val.arr, 0, len);
        rb_size_t i = 0;
        for (i = 0; i < capacity; ++i)
        {
            rb_init_uint32(obj_val.arr + i);
        }
    }
    return obj_val;
}

rb_bool_t rb_append_to_uint32_array(const uint32_t * item, uint32_array_t * obj_val)
{
    if (!item || !obj_val || !obj_val->arr || obj_val->size >= obj_val->capacity)
    {
        return false;
    }
    uint32_t * dst = obj_val->arr + obj_val->size;
    if (rb_set_uint32(item, dst))
    {
        ++obj_val->size;
        return true;
    }
    return false;
}

void rb_init_uint32_array(uint32_array_t * obj_val)
{
    if (!obj_val || !obj_val->arr || obj_val->capacity < 1)
    {
        return;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->capacity; ++i)
    {
        rb_init_uint32(obj_val->arr + i);
    }
}

rb_bool_t rb_set_uint32_array(const uint32_array_t * src, uint32_array_t * dst)
{
    if(!src || !src->arr || !dst)
    {
        return false;
    }
    if (src->size < 1)
    {
        memset(dst, 0, sizeof(uint32_array_t));
        return true;
    }
    *dst = rb_create_uint32_array(src->size);
    dst->size = src->size;
    rb_size_t i = 0;
    for (i = 0; i < dst->size; ++i)
    {
        if (!rb_set_uint32(src->arr + i, dst->arr + i))
        {
            rb_dispose_uint32_array(dst);
            return false;
        }
    }
    return true;
}

rb_bool_t rb_eq_uint32_array(const uint32_array_t * src, const uint32_array_t * dst)
{
    if(!src || !dst)
    {
        return false;
    }
    if (!src->arr && !dst->arr)
    {
        return true;
    }
    if(!src->arr || !dst->arr || (src->size != dst->size))
    {
        return false;
    }
    rb_size_t i = 0;
    for (i = 0; i < src->size; ++i)
    {
        if (!rb_eq_uint32(src->arr + i, dst->arr + i))
        {
            return false;
        }
    }
    return true;
}

void rb_dispose_uint32_array(uint32_array_t * obj_val)
{
    if (!obj_val || !obj_val->arr)
    {
        return;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        rb_dispose_uint32(obj_val->arr + i);
    }
    rb_free(obj_val->arr);
    memset(obj_val, 0, sizeof(uint32_array_t));
}

rb_size_t rb_sizeof_uint32_array(const uint32_array_t * obj_val)
{
    rb_size_t size = sizeof(rb_size_t) + obj_val->size * sizeof(rb_size_t);
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        size += rb_sizeof_uint32(obj_val->arr + i);
    }
    return size;
}

rb_bool_t rb_encode_uint32_array(const uint32_array_t * obj_val, rb_buf_t * rb_val)
{
    if (!obj_val || !obj_val->arr)
    {
        return false;
    }
    rb_buf_t buf = rb_nested_buf(rb_val, 0);
    if (buf.size < 1)
    {
        return false;
    }
    if (!rb_set_array_count(obj_val->size, &buf))
    {
        return false;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        if (!rb_set_array_table_item(i, buf.pos - buf.start, &buf))
        {
            return false;
        }
        if (!rb_encode_uint32(obj_val->arr + i, &buf))
        {
            return false;
        }
    }
    rb_val->pos = buf.pos;
    return true;
}

rb_bool_t rb_decode_uint32_array(const rb_buf_t * rb_val, rb_offset_t offset, uint32_array_t * obj_val)
{
    if (!obj_val)
    {
        return false;
    }
    rb_buf_t buf = rb_nested_buf(rb_val, offset);
    if (buf.size < 1)
    {
        return false;
    }
    rb_size_t size = rb_get_array_count(&buf);
    if (size < 1)
    {
        memset(obj_val, 0, sizeof(uint32_array_t));
        return true;
    }

    *obj_val = rb_create_uint32_array(size);
    obj_val->size = size;

    rb_bool_t rc = true;
    rb_offset_t off = 0;
    rb_size_t i = 0;
    for (i = 0; i < size; ++i)
    {
        if (!rb_get_array_table_item(i, &buf, &off))
        {
            rc = false;
            break;
        }
        if (!rb_decode_uint32(&buf, off, obj_val->arr + i))
        {
            rc = false;
            break;
        }
    }
    if (!rc)
    {
        rb_dispose_uint32_array(obj_val);
    }
    return rc;
}

int64_array_t rb_create_int64_array(rb_size_t capacity)
{
    int64_array_t obj_val = { capacity, 0, 0 };
    if (capacity > 0)
    {
        rb_size_t len = capacity * sizeof(int64_t);
        obj_val.arr = (int64_t *) rb_malloc(len);
        memset(obj_val.arr, 0, len);
        rb_size_t i = 0;
        for (i = 0; i < capacity; ++i)
        {
            rb_init_int64(obj_val.arr + i);
        }
    }
    return obj_val;
}

rb_bool_t rb_append_to_int64_array(const int64_t * item, int64_array_t * obj_val)
{
    if (!item || !obj_val || !obj_val->arr || obj_val->size >= obj_val->capacity)
    {
        return false;
    }
    int64_t * dst = obj_val->arr + obj_val->size;
    if (rb_set_int64(item, dst))
    {
        ++obj_val->size;
        return true;
    }
    return false;
}

void rb_init_int64_array(int64_array_t * obj_val)
{
    if (!obj_val || !obj_val->arr || obj_val->capacity < 1)
    {
        return;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->capacity; ++i)
    {
        rb_init_int64(obj_val->arr + i);
    }
}

rb_bool_t rb_set_int64_array(const int64_array_t * src, int64_array_t * dst)
{
    if(!src || !src->arr || !dst)
    {
        return false;
    }
    if (src->size < 1)
    {
        memset(dst, 0, sizeof(int64_array_t));
        return true;
    }
    *dst = rb_create_int64_array(src->size);
    dst->size = src->size;
    rb_size_t i = 0;
    for (i = 0; i < dst->size; ++i)
    {
        if (!rb_set_int64(src->arr + i, dst->arr + i))
        {
            rb_dispose_int64_array(dst);
            return false;
        }
    }
    return true;
}

rb_bool_t rb_eq_int64_array(const int64_array_t * src, const int64_array_t * dst)
{
    if(!src || !dst)
    {
        return false;
    }
    if (!src->arr && !dst->arr)
    {
        return true;
    }
    if(!src->arr || !dst->arr || (src->size != dst->size))
    {
        return false;
    }
    rb_size_t i = 0;
    for (i = 0; i < src->size; ++i)
    {
        if (!rb_eq_int64(src->arr + i, dst->arr + i))
        {
            return false;
        }
    }
    return true;
}

void rb_dispose_int64_array(int64_array_t * obj_val)
{
    if (!obj_val || !obj_val->arr)
    {
        return;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        rb_dispose_int64(obj_val->arr + i);
    }
    rb_free(obj_val->arr);
    memset(obj_val, 0, sizeof(int64_array_t));
}

rb_size_t rb_sizeof_int64_array(const int64_array_t * obj_val)
{
    rb_size_t size = sizeof(rb_size_t) + obj_val->size * sizeof(rb_size_t);
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        size += rb_sizeof_int64(obj_val->arr + i);
    }
    return size;
}

rb_bool_t rb_encode_int64_array(const int64_array_t * obj_val, rb_buf_t * rb_val)
{
    if (!obj_val || !obj_val->arr)
    {
        return false;
    }
    rb_buf_t buf = rb_nested_buf(rb_val, 0);
    if (buf.size < 1)
    {
        return false;
    }
    if (!rb_set_array_count(obj_val->size, &buf))
    {
        return false;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        if (!rb_set_array_table_item(i, buf.pos - buf.start, &buf))
        {
            return false;
        }
        if (!rb_encode_int64(obj_val->arr + i, &buf))
        {
            return false;
        }
    }
    rb_val->pos = buf.pos;
    return true;
}

rb_bool_t rb_decode_int64_array(const rb_buf_t * rb_val, rb_offset_t offset, int64_array_t * obj_val)
{
    if (!obj_val)
    {
        return false;
    }
    rb_buf_t buf = rb_nested_buf(rb_val, offset);
    if (buf.size < 1)
    {
        return false;
    }
    rb_size_t size = rb_get_array_count(&buf);
    if (size < 1)
    {
        memset(obj_val, 0, sizeof(int64_array_t));
        return true;
    }

    *obj_val = rb_create_int64_array(size);
    obj_val->size = size;

    rb_bool_t rc = true;
    rb_offset_t off = 0;
    rb_size_t i = 0;
    for (i = 0; i < size; ++i)
    {
        if (!rb_get_array_table_item(i, &buf, &off))
        {
            rc = false;
            break;
        }
        if (!rb_decode_int64(&buf, off, obj_val->arr + i))
        {
            rc = false;
            break;
        }
    }
    if (!rc)
    {
        rb_dispose_int64_array(obj_val);
    }
    return rc;
}

uint64_array_t rb_create_uint64_array(rb_size_t capacity)
{
    uint64_array_t obj_val = { capacity, 0, 0 };
    if (capacity > 0)
    {
        rb_size_t len = capacity * sizeof(uint64_t);
        obj_val.arr = (uint64_t *) rb_malloc(len);
        memset(obj_val.arr, 0, len);
        rb_size_t i = 0;
        for (i = 0; i < capacity; ++i)
        {
            rb_init_uint64(obj_val.arr + i);
        }
    }
    return obj_val;
}

rb_bool_t rb_append_to_uint64_array(const uint64_t * item, uint64_array_t * obj_val)
{
    if (!item || !obj_val || !obj_val->arr || obj_val->size >= obj_val->capacity)
    {
        return false;
    }
    uint64_t * dst = obj_val->arr + obj_val->size;
    if (rb_set_uint64(item, dst))
    {
        ++obj_val->size;
        return true;
    }
    return false;
}

void rb_init_uint64_array(uint64_array_t * obj_val)
{
    if (!obj_val || !obj_val->arr || obj_val->capacity < 1)
    {
        return;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->capacity; ++i)
    {
        rb_init_uint64(obj_val->arr + i);
    }
}

rb_bool_t rb_set_uint64_array(const uint64_array_t * src, uint64_array_t * dst)
{
    if(!src || !src->arr || !dst)
    {
        return false;
    }
    if (src->size < 1)
    {
        memset(dst, 0, sizeof(uint64_array_t));
        return true;
    }
    *dst = rb_create_uint64_array(src->size);
    dst->size = src->size;
    rb_size_t i = 0;
    for (i = 0; i < dst->size; ++i)
    {
        if (!rb_set_uint64(src->arr + i, dst->arr + i))
        {
            rb_dispose_uint64_array(dst);
            return false;
        }
    }
    return true;
}

rb_bool_t rb_eq_uint64_array(const uint64_array_t * src, const uint64_array_t * dst)
{
    if(!src || !dst)
    {
        return false;
    }
    if (!src->arr && !dst->arr)
    {
        return true;
    }
    if(!src->arr || !dst->arr || (src->size != dst->size))
    {
        return false;
    }
    rb_size_t i = 0;
    for (i = 0; i < src->size; ++i)
    {
        if (!rb_eq_uint64(src->arr + i, dst->arr + i))
        {
            return false;
        }
    }
    return true;
}

void rb_dispose_uint64_array(uint64_array_t * obj_val)
{
    if (!obj_val || !obj_val->arr)
    {
        return;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        rb_dispose_uint64(obj_val->arr + i);
    }
    rb_free(obj_val->arr);
    memset(obj_val, 0, sizeof(uint64_array_t));
}

rb_size_t rb_sizeof_uint64_array(const uint64_array_t * obj_val)
{
    rb_size_t size = sizeof(rb_size_t) + obj_val->size * sizeof(rb_size_t);
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        size += rb_sizeof_uint64(obj_val->arr + i);
    }
    return size;
}

rb_bool_t rb_encode_uint64_array(const uint64_array_t * obj_val, rb_buf_t * rb_val)
{
    if (!obj_val || !obj_val->arr)
    {
        return false;
    }
    rb_buf_t buf = rb_nested_buf(rb_val, 0);
    if (buf.size < 1)
    {
        return false;
    }
    if (!rb_set_array_count(obj_val->size, &buf))
    {
        return false;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        if (!rb_set_array_table_item(i, buf.pos - buf.start, &buf))
        {
            return false;
        }
        if (!rb_encode_uint64(obj_val->arr + i, &buf))
        {
            return false;
        }
    }
    rb_val->pos = buf.pos;
    return true;
}

rb_bool_t rb_decode_uint64_array(const rb_buf_t * rb_val, rb_offset_t offset, uint64_array_t * obj_val)
{
    if (!obj_val)
    {
        return false;
    }
    rb_buf_t buf = rb_nested_buf(rb_val, offset);
    if (buf.size < 1)
    {
        return false;
    }
    rb_size_t size = rb_get_array_count(&buf);
    if (size < 1)
    {
        memset(obj_val, 0, sizeof(uint64_array_t));
        return true;
    }

    *obj_val = rb_create_uint64_array(size);
    obj_val->size = size;

    rb_bool_t rc = true;
    rb_offset_t off = 0;
    rb_size_t i = 0;
    for (i = 0; i < size; ++i)
    {
        if (!rb_get_array_table_item(i, &buf, &off))
        {
            rc = false;
            break;
        }
        if (!rb_decode_uint64(&buf, off, obj_val->arr + i))
        {
            rc = false;
            break;
        }
    }
    if (!rc)
    {
        rb_dispose_uint64_array(obj_val);
    }
    return rc;
}

float_array_t rb_create_float_array(rb_size_t capacity)
{
    float_array_t obj_val = { capacity, 0, 0 };
    if (capacity > 0)
    {
        rb_size_t len = capacity * sizeof(float);
        obj_val.arr = (float *) rb_malloc(len);
        memset(obj_val.arr, 0, len);
        rb_size_t i = 0;
        for (i = 0; i < capacity; ++i)
        {
            rb_init_float(obj_val.arr + i);
        }
    }
    return obj_val;
}

rb_bool_t rb_append_to_float_array(const float * item, float_array_t * obj_val)
{
    if (!item || !obj_val || !obj_val->arr || obj_val->size >= obj_val->capacity)
    {
        return false;
    }
    float * dst = obj_val->arr + obj_val->size;
    if (rb_set_float(item, dst))
    {
        ++obj_val->size;
        return true;
    }
    return false;
}

void rb_init_float_array(float_array_t * obj_val)
{
    if (!obj_val || !obj_val->arr || obj_val->capacity < 1)
    {
        return;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->capacity; ++i)
    {
        rb_init_float(obj_val->arr + i);
    }
}

rb_bool_t rb_set_float_array(const float_array_t * src, float_array_t * dst)
{
    if(!src || !src->arr || !dst)
    {
        return false;
    }
    if (src->size < 1)
    {
        memset(dst, 0, sizeof(float_array_t));
        return true;
    }
    *dst = rb_create_float_array(src->size);
    dst->size = src->size;
    rb_size_t i = 0;
    for (i = 0; i < dst->size; ++i)
    {
        if (!rb_set_float(src->arr + i, dst->arr + i))
        {
            rb_dispose_float_array(dst);
            return false;
        }
    }
    return true;
}

rb_bool_t rb_eq_float_array(const float_array_t * src, const float_array_t * dst)
{
    if(!src || !dst)
    {
        return false;
    }
    if (!src->arr && !dst->arr)
    {
        return true;
    }
    if(!src->arr || !dst->arr || (src->size != dst->size))
    {
        return false;
    }
    rb_size_t i = 0;
    for (i = 0; i < src->size; ++i)
    {
        if (!rb_eq_float(src->arr + i, dst->arr + i))
        {
            return false;
        }
    }
    return true;
}

void rb_dispose_float_array(float_array_t * obj_val)
{
    if (!obj_val || !obj_val->arr)
    {
        return;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        rb_dispose_float(obj_val->arr + i);
    }
    rb_free(obj_val->arr);
    memset(obj_val, 0, sizeof(float_array_t));
}

rb_size_t rb_sizeof_float_array(const float_array_t * obj_val)
{
    rb_size_t size = sizeof(rb_size_t) + obj_val->size * sizeof(rb_size_t);
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        size += rb_sizeof_float(obj_val->arr + i);
    }
    return size;
}

rb_bool_t rb_encode_float_array(const float_array_t * obj_val, rb_buf_t * rb_val)
{
    if (!obj_val || !obj_val->arr)
    {
        return false;
    }
    rb_buf_t buf = rb_nested_buf(rb_val, 0);
    if (buf.size < 1)
    {
        return false;
    }
    if (!rb_set_array_count(obj_val->size, &buf))
    {
        return false;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        if (!rb_set_array_table_item(i, buf.pos - buf.start, &buf))
        {
            return false;
        }
        if (!rb_encode_float(obj_val->arr + i, &buf))
        {
            return false;
        }
    }
    rb_val->pos = buf.pos;
    return true;
}

rb_bool_t rb_decode_float_array(const rb_buf_t * rb_val, rb_offset_t offset, float_array_t * obj_val)
{
    if (!obj_val)
    {
        return false;
    }
    rb_buf_t buf = rb_nested_buf(rb_val, offset);
    if (buf.size < 1)
    {
        return false;
    }
    rb_size_t size = rb_get_array_count(&buf);
    if (size < 1)
    {
        memset(obj_val, 0, sizeof(float_array_t));
        return true;
    }

    *obj_val = rb_create_float_array(size);
    obj_val->size = size;

    rb_bool_t rc = true;
    rb_offset_t off = 0;
    rb_size_t i = 0;
    for (i = 0; i < size; ++i)
    {
        if (!rb_get_array_table_item(i, &buf, &off))
        {
            rc = false;
            break;
        }
        if (!rb_decode_float(&buf, off, obj_val->arr + i))
        {
            rc = false;
            break;
        }
    }
    if (!rc)
    {
        rb_dispose_float_array(obj_val);
    }
    return rc;
}

double_array_t rb_create_double_array(rb_size_t capacity)
{
    double_array_t obj_val = { capacity, 0, 0 };
    if (capacity > 0)
    {
        rb_size_t len = capacity * sizeof(double);
        obj_val.arr = (double *) rb_malloc(len);
        memset(obj_val.arr, 0, len);
        rb_size_t i = 0;
        for (i = 0; i < capacity; ++i)
        {
            rb_init_double(obj_val.arr + i);
        }
    }
    return obj_val;
}

rb_bool_t rb_append_to_double_array(const double * item, double_array_t * obj_val)
{
    if (!item || !obj_val || !obj_val->arr || obj_val->size >= obj_val->capacity)
    {
        return false;
    }
    double * dst = obj_val->arr + obj_val->size;
    if (rb_set_double(item, dst))
    {
        ++obj_val->size;
        return true;
    }
    return false;
}

void rb_init_double_array(double_array_t * obj_val)
{
    if (!obj_val || !obj_val->arr || obj_val->capacity < 1)
    {
        return;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->capacity; ++i)
    {
        rb_init_double(obj_val->arr + i);
    }
}

rb_bool_t rb_set_double_array(const double_array_t * src, double_array_t * dst)
{
    if(!src || !src->arr || !dst)
    {
        return false;
    }
    if (src->size < 1)
    {
        memset(dst, 0, sizeof(double_array_t));
        return true;
    }
    *dst = rb_create_double_array(src->size);
    dst->size = src->size;
    rb_size_t i = 0;
    for (i = 0; i < dst->size; ++i)
    {
        if (!rb_set_double(src->arr + i, dst->arr + i))
        {
            rb_dispose_double_array(dst);
            return false;
        }
    }
    return true;
}

rb_bool_t rb_eq_double_array(const double_array_t * src, const double_array_t * dst)
{
    if(!src || !dst)
    {
        return false;
    }
    if (!src->arr && !dst->arr)
    {
        return true;
    }
    if(!src->arr || !dst->arr || (src->size != dst->size))
    {
        return false;
    }
    rb_size_t i = 0;
    for (i = 0; i < src->size; ++i)
    {
        if (!rb_eq_double(src->arr + i, dst->arr + i))
        {
            return false;
        }
    }
    return true;
}

void rb_dispose_double_array(double_array_t * obj_val)
{
    if (!obj_val || !obj_val->arr)
    {
        return;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        rb_dispose_double(obj_val->arr + i);
    }
    rb_free(obj_val->arr);
    memset(obj_val, 0, sizeof(double_array_t));
}

rb_size_t rb_sizeof_double_array(const double_array_t * obj_val)
{
    rb_size_t size = sizeof(rb_size_t) + obj_val->size * sizeof(rb_size_t);
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        size += rb_sizeof_double(obj_val->arr + i);
    }
    return size;
}

rb_bool_t rb_encode_double_array(const double_array_t * obj_val, rb_buf_t * rb_val)
{
    if (!obj_val || !obj_val->arr)
    {
        return false;
    }
    rb_buf_t buf = rb_nested_buf(rb_val, 0);
    if (buf.size < 1)
    {
        return false;
    }
    if (!rb_set_array_count(obj_val->size, &buf))
    {
        return false;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        if (!rb_set_array_table_item(i, buf.pos - buf.start, &buf))
        {
            return false;
        }
        if (!rb_encode_double(obj_val->arr + i, &buf))
        {
            return false;
        }
    }
    rb_val->pos = buf.pos;
    return true;
}

rb_bool_t rb_decode_double_array(const rb_buf_t * rb_val, rb_offset_t offset, double_array_t * obj_val)
{
    if (!obj_val)
    {
        return false;
    }
    rb_buf_t buf = rb_nested_buf(rb_val, offset);
    if (buf.size < 1)
    {
        return false;
    }
    rb_size_t size = rb_get_array_count(&buf);
    if (size < 1)
    {
        memset(obj_val, 0, sizeof(double_array_t));
        return true;
    }

    *obj_val = rb_create_double_array(size);
    obj_val->size = size;

    rb_bool_t rc = true;
    rb_offset_t off = 0;
    rb_size_t i = 0;
    for (i = 0; i < size; ++i)
    {
        if (!rb_get_array_table_item(i, &buf, &off))
        {
            rc = false;
            break;
        }
        if (!rb_decode_double(&buf, off, obj_val->arr + i))
        {
            rc = false;
            break;
        }
    }
    if (!rc)
    {
        rb_dispose_double_array(obj_val);
    }
    return rc;
}

string_array_t rb_create_string_array(rb_size_t capacity)
{
    string_array_t obj_val = { capacity, 0, 0 };
    if (capacity > 0)
    {
        rb_size_t len = capacity * sizeof(rb_str_t);
        obj_val.arr = (rb_str_t *) rb_malloc(len);
        memset(obj_val.arr, 0, len);
        rb_size_t i = 0;
        for (i = 0; i < capacity; ++i)
        {
            rb_init_string(obj_val.arr + i);
        }
    }
    return obj_val;
}

rb_bool_t rb_append_to_string_array(const rb_str_t * item, string_array_t * obj_val)
{
    if (!item || !obj_val || !obj_val->arr || obj_val->size >= obj_val->capacity)
    {
        return false;
    }
    rb_str_t * dst = obj_val->arr + obj_val->size;
    if (rb_set_string(item, dst))
    {
        ++obj_val->size;
        return true;
    }
    return false;
}

void rb_init_string_array(string_array_t * obj_val)
{
    if (!obj_val || !obj_val->arr || obj_val->capacity < 1)
    {
        return;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->capacity; ++i)
    {
        rb_init_string(obj_val->arr + i);
    }
}

rb_bool_t rb_set_string_array(const string_array_t * src, string_array_t * dst)
{
    if(!src || !src->arr || !dst)
    {
        return false;
    }
    if (src->size < 1)
    {
        memset(dst, 0, sizeof(string_array_t));
        return true;
    }
    *dst = rb_create_string_array(src->size);
    dst->size = src->size;
    rb_size_t i = 0;
    for (i = 0; i < dst->size; ++i)
    {
        if (!rb_set_string(src->arr + i, dst->arr + i))
        {
            rb_dispose_string_array(dst);
            return false;
        }
    }
    return true;
}

rb_bool_t rb_eq_string_array(const string_array_t * src, const string_array_t * dst)
{
    if(!src || !dst)
    {
        return false;
    }
    if (!src->arr && !dst->arr)
    {
        return true;
    }
    if(!src->arr || !dst->arr || (src->size != dst->size))
    {
        return false;
    }
    rb_size_t i = 0;
    for (i = 0; i < src->size; ++i)
    {
        if (!rb_eq_string(src->arr + i, dst->arr + i))
        {
            return false;
        }
    }
    return true;
}

void rb_dispose_string_array(string_array_t * obj_val)
{
    if (!obj_val || !obj_val->arr)
    {
        return;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        rb_dispose_string(obj_val->arr + i);
    }
    rb_free(obj_val->arr);
    memset(obj_val, 0, sizeof(string_array_t));
}

rb_size_t rb_sizeof_string_array(const string_array_t * obj_val)
{
    rb_size_t size = sizeof(rb_size_t) + obj_val->size * sizeof(rb_size_t);
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        size += rb_sizeof_string(obj_val->arr + i);
    }
    return size;
}

rb_bool_t rb_encode_string_array(const string_array_t * obj_val, rb_buf_t * rb_val)
{
    if (!obj_val || !obj_val->arr)
    {
        return false;
    }
    rb_buf_t buf = rb_nested_buf(rb_val, 0);
    if (buf.size < 1)
    {
        return false;
    }
    if (!rb_set_array_count(obj_val->size, &buf))
    {
        return false;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        if (!rb_set_array_table_item(i, buf.pos - buf.start, &buf))
        {
            return false;
        }
        if (!rb_encode_string(obj_val->arr + i, &buf))
        {
            return false;
        }
    }
    rb_val->pos = buf.pos;
    return true;
}

rb_bool_t rb_decode_string_array(const rb_buf_t * rb_val, rb_offset_t offset, string_array_t * obj_val)
{
    if (!obj_val)
    {
        return false;
    }
    rb_buf_t buf = rb_nested_buf(rb_val, offset);
    if (buf.size < 1)
    {
        return false;
    }
    rb_size_t size = rb_get_array_count(&buf);
    if (size < 1)
    {
        memset(obj_val, 0, sizeof(string_array_t));
        return true;
    }

    *obj_val = rb_create_string_array(size);
    obj_val->size = size;

    rb_bool_t rc = true;
    rb_offset_t off = 0;
    rb_size_t i = 0;
    for (i = 0; i < size; ++i)
    {
        if (!rb_get_array_table_item(i, &buf, &off))
        {
            rc = false;
            break;
        }
        if (!rb_decode_string(&buf, off, obj_val->arr + i))
        {
            rc = false;
            break;
        }
    }
    if (!rc)
    {
        rb_dispose_string_array(obj_val);
    }
    return rc;
}

bool_dict_t rb_create_bool_dict(rb_size_t capacity)
{
    bool_dict_t obj_val = { capacity, 0, 0 };
    if (capacity > 0)
    {
        rb_size_t len = capacity * sizeof(bool_pair_t);
        obj_val.arr = (bool_pair_t *) rb_malloc(len);
        memset(obj_val.arr, 0, len);
        rb_size_t i = 0;
        for (i = 0; i < capacity; ++i)
        {
            rb_init_string(&(obj_val.arr + i)->key);
            rb_init_bool(&(obj_val.arr + i)->val);
        }
    }
    return obj_val;
}

bool_pair_t * rb_bool_dict_get_item(const bool_dict_t * obj_val, const rb_str_t * key)
{
    if (!obj_val || !key || obj_val->size < 1 || obj_val->capacity < 1)
    {
        return NULL;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        bool_pair_t * item = obj_val->arr + i;
        if (rb_eq_string(key, &item->key))
        {
            return item;
        }
    }
    return NULL;
}

rb_bool_t rb_bool_dict_set_item(const rb_str_t * key, const rb_bool_t * val, bool_dict_t * obj_val)
{
    if (!key || !val || !obj_val || !obj_val->arr || obj_val->size >= obj_val->capacity)
    {
        return false;
    }
    bool_pair_t * it = rb_bool_dict_get_item(obj_val, key);
    if (it)
    {
        rb_dispose_bool(&it->val);
        return rb_set_bool(val, &it->val);
    }
    it = obj_val->arr + obj_val->size;
    if (!rb_set_string(key, &it->key))
    {
        return false;
    }
    if (!rb_set_bool(val, &it->val))
    {
        rb_dispose_string(&it->key);
        return false;
    }
    ++obj_val->size;
    return false;
}

void rb_init_bool_dict(bool_dict_t * obj_val)
{
    if (!obj_val || !obj_val->arr || obj_val->capacity < 1)
    {
        return;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->capacity; ++i)
    {
        bool_pair_t * it = obj_val->arr + i;
        rb_init_string(&it->key);
        rb_init_bool(&it->val);
    }
}

rb_bool_t rb_set_bool_dict(const bool_dict_t * src, bool_dict_t * dst)
{
    if(!src || !src->arr || !dst)
    {
        return false;
    }
    if (src->size < 1)
    {
        memset(dst, 0, sizeof(bool_dict_t));
        return true;
    }
    *dst = rb_create_bool_dict(src->size);
    dst->size = src->size;
    rb_size_t i = 0;
    for (i = 0; i < dst->size; ++i)
    {
        bool_pair_t * it_src = src->arr + i;
        bool_pair_t * it_dst = dst->arr + i;
        if (!rb_set_string(&it_src->key, &it_dst->key))
        {
            rb_dispose_bool_dict(dst);
            return false;
        }
        if (!rb_set_bool(&it_src->val, &it_dst->val))
        {
            rb_dispose_bool_dict(dst);
            return false;
        }
    }
    return true;
}

rb_bool_t rb_eq_bool_dict(const bool_dict_t * src, const bool_dict_t * dst)
{
    if(!src || !dst)
    {
        return false;
    }
    if (!src->arr && !dst->arr)
    {
        return true;
    }
    if(!src->arr || !dst->arr || (src->size != dst->size))
    {
        return false;
    }
    rb_size_t i = 0;
    for (i = 0; i < src->size; ++i)
    {
        bool_pair_t * it_src = src->arr + i;
        bool_pair_t * it_dst = dst->arr + i;
        if (!rb_eq_string(&it_src->key, &it_dst->key))
        {
            return false;
        }
        if (!rb_eq_bool(&it_src->val, &it_dst->val))
        {
            return false;
        }
    }
    return true;
}

void rb_dispose_bool_dict(bool_dict_t * obj_val)
{
    if (!obj_val || !obj_val->arr)
    {
        return;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        bool_pair_t * it = obj_val->arr + i;
        rb_dispose_string(&it->key);
        rb_dispose_bool(&it->val);
    }
    rb_free(obj_val->arr);
    memset(obj_val, 0, sizeof(bool_dict_t));
}

rb_size_t rb_sizeof_bool_dict(const bool_dict_t * obj_val)
{
    rb_size_t size = sizeof(rb_size_t) + obj_val->size * sizeof(rb_size_t);
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        bool_pair_t * it = obj_val->arr + i;
        size += rb_sizeof_string(&it->key);
        size += rb_sizeof_bool(&it->val);
    }
    return size;
}

rb_bool_t rb_encode_bool_dict(const bool_dict_t * obj_val, rb_buf_t * rb_val)
{
    if (!obj_val || !obj_val->arr)
    {
        return false;
    }
    rb_buf_t buf = rb_nested_buf(rb_val, 0);
    if (buf.size < 1)
    {
        return false;
    }
    if (!rb_set_array_count(obj_val->size, &buf))
    {
        return false;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        if (!rb_set_array_table_item(i, buf.pos - buf.start, &buf))
        {
            return false;
        }
        bool_pair_t * it = obj_val->arr + i;
        if (!rb_encode_string(&it->key, &buf))
        {
            return false;
        }
        if (!rb_encode_bool(&it->val, &buf))
        {
            return false;
        }
    }
    rb_val->pos = buf.pos;
    return true;
}

rb_bool_t rb_decode_bool_dict(const rb_buf_t * rb_val, rb_offset_t offset, bool_dict_t * obj_val)
{
    if (!obj_val)
    {
        return false;
    }
    rb_buf_t buf = rb_nested_buf(rb_val, offset);
    if (buf.size < 1)
    {
        return false;
    }
    rb_size_t size = rb_get_array_count(&buf);
    if (size < 1)
    {
        memset(obj_val, 0, sizeof(bool_dict_t));
        return true;
    }

    *obj_val = rb_create_bool_dict(size);
    obj_val->size = size;

    rb_bool_t rc = true;
    rb_offset_t off = 0;
    rb_size_t i = 0;
    for (i = 0; i < size; ++i)
    {
        if (!rb_get_array_table_item(i, &buf, &off))
        {
            rc = false;
            break;
        }
        bool_pair_t * it = obj_val->arr + i;
        if (!rb_decode_string(&buf, off, &it->key))
        {
            rc = false;
            break;
        }
        rb_offset_t delta = rb_sizeof_string(&it->key);
        if (!rb_decode_bool(&buf, off + delta, &it->val))
        {
            rc = false;
            break;
        }
    }
    if (!rc)
    {
        rb_dispose_bool_dict(obj_val);
    }
    return rc;
}

int8_dict_t rb_create_int8_dict(rb_size_t capacity)
{
    int8_dict_t obj_val = { capacity, 0, 0 };
    if (capacity > 0)
    {
        rb_size_t len = capacity * sizeof(int8_pair_t);
        obj_val.arr = (int8_pair_t *) rb_malloc(len);
        memset(obj_val.arr, 0, len);
        rb_size_t i = 0;
        for (i = 0; i < capacity; ++i)
        {
            rb_init_string(&(obj_val.arr + i)->key);
            rb_init_int8(&(obj_val.arr + i)->val);
        }
    }
    return obj_val;
}

int8_pair_t * rb_int8_dict_get_item(const int8_dict_t * obj_val, const rb_str_t * key)
{
    if (!obj_val || !key || obj_val->size < 1 || obj_val->capacity < 1)
    {
        return NULL;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        int8_pair_t * item = obj_val->arr + i;
        if (rb_eq_string(key, &item->key))
        {
            return item;
        }
    }
    return NULL;
}

rb_bool_t rb_int8_dict_set_item(const rb_str_t * key, const int8_t * val, int8_dict_t * obj_val)
{
    if (!key || !val || !obj_val || !obj_val->arr || obj_val->size >= obj_val->capacity)
    {
        return false;
    }
    int8_pair_t * it = rb_int8_dict_get_item(obj_val, key);
    if (it)
    {
        rb_dispose_int8(&it->val);
        return rb_set_int8(val, &it->val);
    }
    it = obj_val->arr + obj_val->size;
    if (!rb_set_string(key, &it->key))
    {
        return false;
    }
    if (!rb_set_int8(val, &it->val))
    {
        rb_dispose_string(&it->key);
        return false;
    }
    ++obj_val->size;
    return false;
}

void rb_init_int8_dict(int8_dict_t * obj_val)
{
    if (!obj_val || !obj_val->arr || obj_val->capacity < 1)
    {
        return;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->capacity; ++i)
    {
        int8_pair_t * it = obj_val->arr + i;
        rb_init_string(&it->key);
        rb_init_int8(&it->val);
    }
}

rb_bool_t rb_set_int8_dict(const int8_dict_t * src, int8_dict_t * dst)
{
    if(!src || !src->arr || !dst)
    {
        return false;
    }
    if (src->size < 1)
    {
        memset(dst, 0, sizeof(int8_dict_t));
        return true;
    }
    *dst = rb_create_int8_dict(src->size);
    dst->size = src->size;
    rb_size_t i = 0;
    for (i = 0; i < dst->size; ++i)
    {
        int8_pair_t * it_src = src->arr + i;
        int8_pair_t * it_dst = dst->arr + i;
        if (!rb_set_string(&it_src->key, &it_dst->key))
        {
            rb_dispose_int8_dict(dst);
            return false;
        }
        if (!rb_set_int8(&it_src->val, &it_dst->val))
        {
            rb_dispose_int8_dict(dst);
            return false;
        }
    }
    return true;
}

rb_bool_t rb_eq_int8_dict(const int8_dict_t * src, const int8_dict_t * dst)
{
    if(!src || !dst)
    {
        return false;
    }
    if (!src->arr && !dst->arr)
    {
        return true;
    }
    if(!src->arr || !dst->arr || (src->size != dst->size))
    {
        return false;
    }
    rb_size_t i = 0;
    for (i = 0; i < src->size; ++i)
    {
        int8_pair_t * it_src = src->arr + i;
        int8_pair_t * it_dst = dst->arr + i;
        if (!rb_eq_string(&it_src->key, &it_dst->key))
        {
            return false;
        }
        if (!rb_eq_int8(&it_src->val, &it_dst->val))
        {
            return false;
        }
    }
    return true;
}

void rb_dispose_int8_dict(int8_dict_t * obj_val)
{
    if (!obj_val || !obj_val->arr)
    {
        return;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        int8_pair_t * it = obj_val->arr + i;
        rb_dispose_string(&it->key);
        rb_dispose_int8(&it->val);
    }
    rb_free(obj_val->arr);
    memset(obj_val, 0, sizeof(int8_dict_t));
}

rb_size_t rb_sizeof_int8_dict(const int8_dict_t * obj_val)
{
    rb_size_t size = sizeof(rb_size_t) + obj_val->size * sizeof(rb_size_t);
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        int8_pair_t * it = obj_val->arr + i;
        size += rb_sizeof_string(&it->key);
        size += rb_sizeof_int8(&it->val);
    }
    return size;
}

rb_bool_t rb_encode_int8_dict(const int8_dict_t * obj_val, rb_buf_t * rb_val)
{
    if (!obj_val || !obj_val->arr)
    {
        return false;
    }
    rb_buf_t buf = rb_nested_buf(rb_val, 0);
    if (buf.size < 1)
    {
        return false;
    }
    if (!rb_set_array_count(obj_val->size, &buf))
    {
        return false;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        if (!rb_set_array_table_item(i, buf.pos - buf.start, &buf))
        {
            return false;
        }
        int8_pair_t * it = obj_val->arr + i;
        if (!rb_encode_string(&it->key, &buf))
        {
            return false;
        }
        if (!rb_encode_int8(&it->val, &buf))
        {
            return false;
        }
    }
    rb_val->pos = buf.pos;
    return true;
}

rb_bool_t rb_decode_int8_dict(const rb_buf_t * rb_val, rb_offset_t offset, int8_dict_t * obj_val)
{
    if (!obj_val)
    {
        return false;
    }
    rb_buf_t buf = rb_nested_buf(rb_val, offset);
    if (buf.size < 1)
    {
        return false;
    }
    rb_size_t size = rb_get_array_count(&buf);
    if (size < 1)
    {
        memset(obj_val, 0, sizeof(int8_dict_t));
        return true;
    }

    *obj_val = rb_create_int8_dict(size);
    obj_val->size = size;

    rb_bool_t rc = true;
    rb_offset_t off = 0;
    rb_size_t i = 0;
    for (i = 0; i < size; ++i)
    {
        if (!rb_get_array_table_item(i, &buf, &off))
        {
            rc = false;
            break;
        }
        int8_pair_t * it = obj_val->arr + i;
        if (!rb_decode_string(&buf, off, &it->key))
        {
            rc = false;
            break;
        }
        rb_offset_t delta = rb_sizeof_string(&it->key);
        if (!rb_decode_int8(&buf, off + delta, &it->val))
        {
            rc = false;
            break;
        }
    }
    if (!rc)
    {
        rb_dispose_int8_dict(obj_val);
    }
    return rc;
}

uint8_dict_t rb_create_uint8_dict(rb_size_t capacity)
{
    uint8_dict_t obj_val = { capacity, 0, 0 };
    if (capacity > 0)
    {
        rb_size_t len = capacity * sizeof(uint8_pair_t);
        obj_val.arr = (uint8_pair_t *) rb_malloc(len);
        memset(obj_val.arr, 0, len);
        rb_size_t i = 0;
        for (i = 0; i < capacity; ++i)
        {
            rb_init_string(&(obj_val.arr + i)->key);
            rb_init_uint8(&(obj_val.arr + i)->val);
        }
    }
    return obj_val;
}

uint8_pair_t * rb_uint8_dict_get_item(const uint8_dict_t * obj_val, const rb_str_t * key)
{
    if (!obj_val || !key || obj_val->size < 1 || obj_val->capacity < 1)
    {
        return NULL;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        uint8_pair_t * item = obj_val->arr + i;
        if (rb_eq_string(key, &item->key))
        {
            return item;
        }
    }
    return NULL;
}

rb_bool_t rb_uint8_dict_set_item(const rb_str_t * key, const uint8_t * val, uint8_dict_t * obj_val)
{
    if (!key || !val || !obj_val || !obj_val->arr || obj_val->size >= obj_val->capacity)
    {
        return false;
    }
    uint8_pair_t * it = rb_uint8_dict_get_item(obj_val, key);
    if (it)
    {
        rb_dispose_uint8(&it->val);
        return rb_set_uint8(val, &it->val);
    }
    it = obj_val->arr + obj_val->size;
    if (!rb_set_string(key, &it->key))
    {
        return false;
    }
    if (!rb_set_uint8(val, &it->val))
    {
        rb_dispose_string(&it->key);
        return false;
    }
    ++obj_val->size;
    return false;
}

void rb_init_uint8_dict(uint8_dict_t * obj_val)
{
    if (!obj_val || !obj_val->arr || obj_val->capacity < 1)
    {
        return;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->capacity; ++i)
    {
        uint8_pair_t * it = obj_val->arr + i;
        rb_init_string(&it->key);
        rb_init_uint8(&it->val);
    }
}

rb_bool_t rb_set_uint8_dict(const uint8_dict_t * src, uint8_dict_t * dst)
{
    if(!src || !src->arr || !dst)
    {
        return false;
    }
    if (src->size < 1)
    {
        memset(dst, 0, sizeof(uint8_dict_t));
        return true;
    }
    *dst = rb_create_uint8_dict(src->size);
    dst->size = src->size;
    rb_size_t i = 0;
    for (i = 0; i < dst->size; ++i)
    {
        uint8_pair_t * it_src = src->arr + i;
        uint8_pair_t * it_dst = dst->arr + i;
        if (!rb_set_string(&it_src->key, &it_dst->key))
        {
            rb_dispose_uint8_dict(dst);
            return false;
        }
        if (!rb_set_uint8(&it_src->val, &it_dst->val))
        {
            rb_dispose_uint8_dict(dst);
            return false;
        }
    }
    return true;
}

rb_bool_t rb_eq_uint8_dict(const uint8_dict_t * src, const uint8_dict_t * dst)
{
    if(!src || !dst)
    {
        return false;
    }
    if (!src->arr && !dst->arr)
    {
        return true;
    }
    if(!src->arr || !dst->arr || (src->size != dst->size))
    {
        return false;
    }
    rb_size_t i = 0;
    for (i = 0; i < src->size; ++i)
    {
        uint8_pair_t * it_src = src->arr + i;
        uint8_pair_t * it_dst = dst->arr + i;
        if (!rb_eq_string(&it_src->key, &it_dst->key))
        {
            return false;
        }
        if (!rb_eq_uint8(&it_src->val, &it_dst->val))
        {
            return false;
        }
    }
    return true;
}

void rb_dispose_uint8_dict(uint8_dict_t * obj_val)
{
    if (!obj_val || !obj_val->arr)
    {
        return;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        uint8_pair_t * it = obj_val->arr + i;
        rb_dispose_string(&it->key);
        rb_dispose_uint8(&it->val);
    }
    rb_free(obj_val->arr);
    memset(obj_val, 0, sizeof(uint8_dict_t));
}

rb_size_t rb_sizeof_uint8_dict(const uint8_dict_t * obj_val)
{
    rb_size_t size = sizeof(rb_size_t) + obj_val->size * sizeof(rb_size_t);
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        uint8_pair_t * it = obj_val->arr + i;
        size += rb_sizeof_string(&it->key);
        size += rb_sizeof_uint8(&it->val);
    }
    return size;
}

rb_bool_t rb_encode_uint8_dict(const uint8_dict_t * obj_val, rb_buf_t * rb_val)
{
    if (!obj_val || !obj_val->arr)
    {
        return false;
    }
    rb_buf_t buf = rb_nested_buf(rb_val, 0);
    if (buf.size < 1)
    {
        return false;
    }
    if (!rb_set_array_count(obj_val->size, &buf))
    {
        return false;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        if (!rb_set_array_table_item(i, buf.pos - buf.start, &buf))
        {
            return false;
        }
        uint8_pair_t * it = obj_val->arr + i;
        if (!rb_encode_string(&it->key, &buf))
        {
            return false;
        }
        if (!rb_encode_uint8(&it->val, &buf))
        {
            return false;
        }
    }
    rb_val->pos = buf.pos;
    return true;
}

rb_bool_t rb_decode_uint8_dict(const rb_buf_t * rb_val, rb_offset_t offset, uint8_dict_t * obj_val)
{
    if (!obj_val)
    {
        return false;
    }
    rb_buf_t buf = rb_nested_buf(rb_val, offset);
    if (buf.size < 1)
    {
        return false;
    }
    rb_size_t size = rb_get_array_count(&buf);
    if (size < 1)
    {
        memset(obj_val, 0, sizeof(uint8_dict_t));
        return true;
    }

    *obj_val = rb_create_uint8_dict(size);
    obj_val->size = size;

    rb_bool_t rc = true;
    rb_offset_t off = 0;
    rb_size_t i = 0;
    for (i = 0; i < size; ++i)
    {
        if (!rb_get_array_table_item(i, &buf, &off))
        {
            rc = false;
            break;
        }
        uint8_pair_t * it = obj_val->arr + i;
        if (!rb_decode_string(&buf, off, &it->key))
        {
            rc = false;
            break;
        }
        rb_offset_t delta = rb_sizeof_string(&it->key);
        if (!rb_decode_uint8(&buf, off + delta, &it->val))
        {
            rc = false;
            break;
        }
    }
    if (!rc)
    {
        rb_dispose_uint8_dict(obj_val);
    }
    return rc;
}

int16_dict_t rb_create_int16_dict(rb_size_t capacity)
{
    int16_dict_t obj_val = { capacity, 0, 0 };
    if (capacity > 0)
    {
        rb_size_t len = capacity * sizeof(int16_pair_t);
        obj_val.arr = (int16_pair_t *) rb_malloc(len);
        memset(obj_val.arr, 0, len);
        rb_size_t i = 0;
        for (i = 0; i < capacity; ++i)
        {
            rb_init_string(&(obj_val.arr + i)->key);
            rb_init_int16(&(obj_val.arr + i)->val);
        }
    }
    return obj_val;
}

int16_pair_t * rb_int16_dict_get_item(const int16_dict_t * obj_val, const rb_str_t * key)
{
    if (!obj_val || !key || obj_val->size < 1 || obj_val->capacity < 1)
    {
        return NULL;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        int16_pair_t * item = obj_val->arr + i;
        if (rb_eq_string(key, &item->key))
        {
            return item;
        }
    }
    return NULL;
}

rb_bool_t rb_int16_dict_set_item(const rb_str_t * key, const int16_t * val, int16_dict_t * obj_val)
{
    if (!key || !val || !obj_val || !obj_val->arr || obj_val->size >= obj_val->capacity)
    {
        return false;
    }
    int16_pair_t * it = rb_int16_dict_get_item(obj_val, key);
    if (it)
    {
        rb_dispose_int16(&it->val);
        return rb_set_int16(val, &it->val);
    }
    it = obj_val->arr + obj_val->size;
    if (!rb_set_string(key, &it->key))
    {
        return false;
    }
    if (!rb_set_int16(val, &it->val))
    {
        rb_dispose_string(&it->key);
        return false;
    }
    ++obj_val->size;
    return false;
}

void rb_init_int16_dict(int16_dict_t * obj_val)
{
    if (!obj_val || !obj_val->arr || obj_val->capacity < 1)
    {
        return;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->capacity; ++i)
    {
        int16_pair_t * it = obj_val->arr + i;
        rb_init_string(&it->key);
        rb_init_int16(&it->val);
    }
}

rb_bool_t rb_set_int16_dict(const int16_dict_t * src, int16_dict_t * dst)
{
    if(!src || !src->arr || !dst)
    {
        return false;
    }
    if (src->size < 1)
    {
        memset(dst, 0, sizeof(int16_dict_t));
        return true;
    }
    *dst = rb_create_int16_dict(src->size);
    dst->size = src->size;
    rb_size_t i = 0;
    for (i = 0; i < dst->size; ++i)
    {
        int16_pair_t * it_src = src->arr + i;
        int16_pair_t * it_dst = dst->arr + i;
        if (!rb_set_string(&it_src->key, &it_dst->key))
        {
            rb_dispose_int16_dict(dst);
            return false;
        }
        if (!rb_set_int16(&it_src->val, &it_dst->val))
        {
            rb_dispose_int16_dict(dst);
            return false;
        }
    }
    return true;
}

rb_bool_t rb_eq_int16_dict(const int16_dict_t * src, const int16_dict_t * dst)
{
    if(!src || !dst)
    {
        return false;
    }
    if (!src->arr && !dst->arr)
    {
        return true;
    }
    if(!src->arr || !dst->arr || (src->size != dst->size))
    {
        return false;
    }
    rb_size_t i = 0;
    for (i = 0; i < src->size; ++i)
    {
        int16_pair_t * it_src = src->arr + i;
        int16_pair_t * it_dst = dst->arr + i;
        if (!rb_eq_string(&it_src->key, &it_dst->key))
        {
            return false;
        }
        if (!rb_eq_int16(&it_src->val, &it_dst->val))
        {
            return false;
        }
    }
    return true;
}

void rb_dispose_int16_dict(int16_dict_t * obj_val)
{
    if (!obj_val || !obj_val->arr)
    {
        return;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        int16_pair_t * it = obj_val->arr + i;
        rb_dispose_string(&it->key);
        rb_dispose_int16(&it->val);
    }
    rb_free(obj_val->arr);
    memset(obj_val, 0, sizeof(int16_dict_t));
}

rb_size_t rb_sizeof_int16_dict(const int16_dict_t * obj_val)
{
    rb_size_t size = sizeof(rb_size_t) + obj_val->size * sizeof(rb_size_t);
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        int16_pair_t * it = obj_val->arr + i;
        size += rb_sizeof_string(&it->key);
        size += rb_sizeof_int16(&it->val);
    }
    return size;
}

rb_bool_t rb_encode_int16_dict(const int16_dict_t * obj_val, rb_buf_t * rb_val)
{
    if (!obj_val || !obj_val->arr)
    {
        return false;
    }
    rb_buf_t buf = rb_nested_buf(rb_val, 0);
    if (buf.size < 1)
    {
        return false;
    }
    if (!rb_set_array_count(obj_val->size, &buf))
    {
        return false;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        if (!rb_set_array_table_item(i, buf.pos - buf.start, &buf))
        {
            return false;
        }
        int16_pair_t * it = obj_val->arr + i;
        if (!rb_encode_string(&it->key, &buf))
        {
            return false;
        }
        if (!rb_encode_int16(&it->val, &buf))
        {
            return false;
        }
    }
    rb_val->pos = buf.pos;
    return true;
}

rb_bool_t rb_decode_int16_dict(const rb_buf_t * rb_val, rb_offset_t offset, int16_dict_t * obj_val)
{
    if (!obj_val)
    {
        return false;
    }
    rb_buf_t buf = rb_nested_buf(rb_val, offset);
    if (buf.size < 1)
    {
        return false;
    }
    rb_size_t size = rb_get_array_count(&buf);
    if (size < 1)
    {
        memset(obj_val, 0, sizeof(int16_dict_t));
        return true;
    }

    *obj_val = rb_create_int16_dict(size);
    obj_val->size = size;

    rb_bool_t rc = true;
    rb_offset_t off = 0;
    rb_size_t i = 0;
    for (i = 0; i < size; ++i)
    {
        if (!rb_get_array_table_item(i, &buf, &off))
        {
            rc = false;
            break;
        }
        int16_pair_t * it = obj_val->arr + i;
        if (!rb_decode_string(&buf, off, &it->key))
        {
            rc = false;
            break;
        }
        rb_offset_t delta = rb_sizeof_string(&it->key);
        if (!rb_decode_int16(&buf, off + delta, &it->val))
        {
            rc = false;
            break;
        }
    }
    if (!rc)
    {
        rb_dispose_int16_dict(obj_val);
    }
    return rc;
}

uint16_dict_t rb_create_uint16_dict(rb_size_t capacity)
{
    uint16_dict_t obj_val = { capacity, 0, 0 };
    if (capacity > 0)
    {
        rb_size_t len = capacity * sizeof(uint16_pair_t);
        obj_val.arr = (uint16_pair_t *) rb_malloc(len);
        memset(obj_val.arr, 0, len);
        rb_size_t i = 0;
        for (i = 0; i < capacity; ++i)
        {
            rb_init_string(&(obj_val.arr + i)->key);
            rb_init_uint16(&(obj_val.arr + i)->val);
        }
    }
    return obj_val;
}

uint16_pair_t * rb_uint16_dict_get_item(const uint16_dict_t * obj_val, const rb_str_t * key)
{
    if (!obj_val || !key || obj_val->size < 1 || obj_val->capacity < 1)
    {
        return NULL;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        uint16_pair_t * item = obj_val->arr + i;
        if (rb_eq_string(key, &item->key))
        {
            return item;
        }
    }
    return NULL;
}

rb_bool_t rb_uint16_dict_set_item(const rb_str_t * key, const uint16_t * val, uint16_dict_t * obj_val)
{
    if (!key || !val || !obj_val || !obj_val->arr || obj_val->size >= obj_val->capacity)
    {
        return false;
    }
    uint16_pair_t * it = rb_uint16_dict_get_item(obj_val, key);
    if (it)
    {
        rb_dispose_uint16(&it->val);
        return rb_set_uint16(val, &it->val);
    }
    it = obj_val->arr + obj_val->size;
    if (!rb_set_string(key, &it->key))
    {
        return false;
    }
    if (!rb_set_uint16(val, &it->val))
    {
        rb_dispose_string(&it->key);
        return false;
    }
    ++obj_val->size;
    return false;
}

void rb_init_uint16_dict(uint16_dict_t * obj_val)
{
    if (!obj_val || !obj_val->arr || obj_val->capacity < 1)
    {
        return;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->capacity; ++i)
    {
        uint16_pair_t * it = obj_val->arr + i;
        rb_init_string(&it->key);
        rb_init_uint16(&it->val);
    }
}

rb_bool_t rb_set_uint16_dict(const uint16_dict_t * src, uint16_dict_t * dst)
{
    if(!src || !src->arr || !dst)
    {
        return false;
    }
    if (src->size < 1)
    {
        memset(dst, 0, sizeof(uint16_dict_t));
        return true;
    }
    *dst = rb_create_uint16_dict(src->size);
    dst->size = src->size;
    rb_size_t i = 0;
    for (i = 0; i < dst->size; ++i)
    {
        uint16_pair_t * it_src = src->arr + i;
        uint16_pair_t * it_dst = dst->arr + i;
        if (!rb_set_string(&it_src->key, &it_dst->key))
        {
            rb_dispose_uint16_dict(dst);
            return false;
        }
        if (!rb_set_uint16(&it_src->val, &it_dst->val))
        {
            rb_dispose_uint16_dict(dst);
            return false;
        }
    }
    return true;
}

rb_bool_t rb_eq_uint16_dict(const uint16_dict_t * src, const uint16_dict_t * dst)
{
    if(!src || !dst)
    {
        return false;
    }
    if (!src->arr && !dst->arr)
    {
        return true;
    }
    if(!src->arr || !dst->arr || (src->size != dst->size))
    {
        return false;
    }
    rb_size_t i = 0;
    for (i = 0; i < src->size; ++i)
    {
        uint16_pair_t * it_src = src->arr + i;
        uint16_pair_t * it_dst = dst->arr + i;
        if (!rb_eq_string(&it_src->key, &it_dst->key))
        {
            return false;
        }
        if (!rb_eq_uint16(&it_src->val, &it_dst->val))
        {
            return false;
        }
    }
    return true;
}

void rb_dispose_uint16_dict(uint16_dict_t * obj_val)
{
    if (!obj_val || !obj_val->arr)
    {
        return;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        uint16_pair_t * it = obj_val->arr + i;
        rb_dispose_string(&it->key);
        rb_dispose_uint16(&it->val);
    }
    rb_free(obj_val->arr);
    memset(obj_val, 0, sizeof(uint16_dict_t));
}

rb_size_t rb_sizeof_uint16_dict(const uint16_dict_t * obj_val)
{
    rb_size_t size = sizeof(rb_size_t) + obj_val->size * sizeof(rb_size_t);
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        uint16_pair_t * it = obj_val->arr + i;
        size += rb_sizeof_string(&it->key);
        size += rb_sizeof_uint16(&it->val);
    }
    return size;
}

rb_bool_t rb_encode_uint16_dict(const uint16_dict_t * obj_val, rb_buf_t * rb_val)
{
    if (!obj_val || !obj_val->arr)
    {
        return false;
    }
    rb_buf_t buf = rb_nested_buf(rb_val, 0);
    if (buf.size < 1)
    {
        return false;
    }
    if (!rb_set_array_count(obj_val->size, &buf))
    {
        return false;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        if (!rb_set_array_table_item(i, buf.pos - buf.start, &buf))
        {
            return false;
        }
        uint16_pair_t * it = obj_val->arr + i;
        if (!rb_encode_string(&it->key, &buf))
        {
            return false;
        }
        if (!rb_encode_uint16(&it->val, &buf))
        {
            return false;
        }
    }
    rb_val->pos = buf.pos;
    return true;
}

rb_bool_t rb_decode_uint16_dict(const rb_buf_t * rb_val, rb_offset_t offset, uint16_dict_t * obj_val)
{
    if (!obj_val)
    {
        return false;
    }
    rb_buf_t buf = rb_nested_buf(rb_val, offset);
    if (buf.size < 1)
    {
        return false;
    }
    rb_size_t size = rb_get_array_count(&buf);
    if (size < 1)
    {
        memset(obj_val, 0, sizeof(uint16_dict_t));
        return true;
    }

    *obj_val = rb_create_uint16_dict(size);
    obj_val->size = size;

    rb_bool_t rc = true;
    rb_offset_t off = 0;
    rb_size_t i = 0;
    for (i = 0; i < size; ++i)
    {
        if (!rb_get_array_table_item(i, &buf, &off))
        {
            rc = false;
            break;
        }
        uint16_pair_t * it = obj_val->arr + i;
        if (!rb_decode_string(&buf, off, &it->key))
        {
            rc = false;
            break;
        }
        rb_offset_t delta = rb_sizeof_string(&it->key);
        if (!rb_decode_uint16(&buf, off + delta, &it->val))
        {
            rc = false;
            break;
        }
    }
    if (!rc)
    {
        rb_dispose_uint16_dict(obj_val);
    }
    return rc;
}

int32_dict_t rb_create_int32_dict(rb_size_t capacity)
{
    int32_dict_t obj_val = { capacity, 0, 0 };
    if (capacity > 0)
    {
        rb_size_t len = capacity * sizeof(int32_pair_t);
        obj_val.arr = (int32_pair_t *) rb_malloc(len);
        memset(obj_val.arr, 0, len);
        rb_size_t i = 0;
        for (i = 0; i < capacity; ++i)
        {
            rb_init_string(&(obj_val.arr + i)->key);
            rb_init_int32(&(obj_val.arr + i)->val);
        }
    }
    return obj_val;
}

int32_pair_t * rb_int32_dict_get_item(const int32_dict_t * obj_val, const rb_str_t * key)
{
    if (!obj_val || !key || obj_val->size < 1 || obj_val->capacity < 1)
    {
        return NULL;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        int32_pair_t * item = obj_val->arr + i;
        if (rb_eq_string(key, &item->key))
        {
            return item;
        }
    }
    return NULL;
}

rb_bool_t rb_int32_dict_set_item(const rb_str_t * key, const int32_t * val, int32_dict_t * obj_val)
{
    if (!key || !val || !obj_val || !obj_val->arr || obj_val->size >= obj_val->capacity)
    {
        return false;
    }
    int32_pair_t * it = rb_int32_dict_get_item(obj_val, key);
    if (it)
    {
        rb_dispose_int32(&it->val);
        return rb_set_int32(val, &it->val);
    }
    it = obj_val->arr + obj_val->size;
    if (!rb_set_string(key, &it->key))
    {
        return false;
    }
    if (!rb_set_int32(val, &it->val))
    {
        rb_dispose_string(&it->key);
        return false;
    }
    ++obj_val->size;
    return false;
}

void rb_init_int32_dict(int32_dict_t * obj_val)
{
    if (!obj_val || !obj_val->arr || obj_val->capacity < 1)
    {
        return;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->capacity; ++i)
    {
        int32_pair_t * it = obj_val->arr + i;
        rb_init_string(&it->key);
        rb_init_int32(&it->val);
    }
}

rb_bool_t rb_set_int32_dict(const int32_dict_t * src, int32_dict_t * dst)
{
    if(!src || !src->arr || !dst)
    {
        return false;
    }
    if (src->size < 1)
    {
        memset(dst, 0, sizeof(int32_dict_t));
        return true;
    }
    *dst = rb_create_int32_dict(src->size);
    dst->size = src->size;
    rb_size_t i = 0;
    for (i = 0; i < dst->size; ++i)
    {
        int32_pair_t * it_src = src->arr + i;
        int32_pair_t * it_dst = dst->arr + i;
        if (!rb_set_string(&it_src->key, &it_dst->key))
        {
            rb_dispose_int32_dict(dst);
            return false;
        }
        if (!rb_set_int32(&it_src->val, &it_dst->val))
        {
            rb_dispose_int32_dict(dst);
            return false;
        }
    }
    return true;
}

rb_bool_t rb_eq_int32_dict(const int32_dict_t * src, const int32_dict_t * dst)
{
    if(!src || !dst)
    {
        return false;
    }
    if (!src->arr && !dst->arr)
    {
        return true;
    }
    if(!src->arr || !dst->arr || (src->size != dst->size))
    {
        return false;
    }
    rb_size_t i = 0;
    for (i = 0; i < src->size; ++i)
    {
        int32_pair_t * it_src = src->arr + i;
        int32_pair_t * it_dst = dst->arr + i;
        if (!rb_eq_string(&it_src->key, &it_dst->key))
        {
            return false;
        }
        if (!rb_eq_int32(&it_src->val, &it_dst->val))
        {
            return false;
        }
    }
    return true;
}

void rb_dispose_int32_dict(int32_dict_t * obj_val)
{
    if (!obj_val || !obj_val->arr)
    {
        return;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        int32_pair_t * it = obj_val->arr + i;
        rb_dispose_string(&it->key);
        rb_dispose_int32(&it->val);
    }
    rb_free(obj_val->arr);
    memset(obj_val, 0, sizeof(int32_dict_t));
}

rb_size_t rb_sizeof_int32_dict(const int32_dict_t * obj_val)
{
    rb_size_t size = sizeof(rb_size_t) + obj_val->size * sizeof(rb_size_t);
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        int32_pair_t * it = obj_val->arr + i;
        size += rb_sizeof_string(&it->key);
        size += rb_sizeof_int32(&it->val);
    }
    return size;
}

rb_bool_t rb_encode_int32_dict(const int32_dict_t * obj_val, rb_buf_t * rb_val)
{
    if (!obj_val || !obj_val->arr)
    {
        return false;
    }
    rb_buf_t buf = rb_nested_buf(rb_val, 0);
    if (buf.size < 1)
    {
        return false;
    }
    if (!rb_set_array_count(obj_val->size, &buf))
    {
        return false;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        if (!rb_set_array_table_item(i, buf.pos - buf.start, &buf))
        {
            return false;
        }
        int32_pair_t * it = obj_val->arr + i;
        if (!rb_encode_string(&it->key, &buf))
        {
            return false;
        }
        if (!rb_encode_int32(&it->val, &buf))
        {
            return false;
        }
    }
    rb_val->pos = buf.pos;
    return true;
}

rb_bool_t rb_decode_int32_dict(const rb_buf_t * rb_val, rb_offset_t offset, int32_dict_t * obj_val)
{
    if (!obj_val)
    {
        return false;
    }
    rb_buf_t buf = rb_nested_buf(rb_val, offset);
    if (buf.size < 1)
    {
        return false;
    }
    rb_size_t size = rb_get_array_count(&buf);
    if (size < 1)
    {
        memset(obj_val, 0, sizeof(int32_dict_t));
        return true;
    }

    *obj_val = rb_create_int32_dict(size);
    obj_val->size = size;

    rb_bool_t rc = true;
    rb_offset_t off = 0;
    rb_size_t i = 0;
    for (i = 0; i < size; ++i)
    {
        if (!rb_get_array_table_item(i, &buf, &off))
        {
            rc = false;
            break;
        }
        int32_pair_t * it = obj_val->arr + i;
        if (!rb_decode_string(&buf, off, &it->key))
        {
            rc = false;
            break;
        }
        rb_offset_t delta = rb_sizeof_string(&it->key);
        if (!rb_decode_int32(&buf, off + delta, &it->val))
        {
            rc = false;
            break;
        }
    }
    if (!rc)
    {
        rb_dispose_int32_dict(obj_val);
    }
    return rc;
}

uint32_dict_t rb_create_uint32_dict(rb_size_t capacity)
{
    uint32_dict_t obj_val = { capacity, 0, 0 };
    if (capacity > 0)
    {
        rb_size_t len = capacity * sizeof(uint32_pair_t);
        obj_val.arr = (uint32_pair_t *) rb_malloc(len);
        memset(obj_val.arr, 0, len);
        rb_size_t i = 0;
        for (i = 0; i < capacity; ++i)
        {
            rb_init_string(&(obj_val.arr + i)->key);
            rb_init_uint32(&(obj_val.arr + i)->val);
        }
    }
    return obj_val;
}

uint32_pair_t * rb_uint32_dict_get_item(const uint32_dict_t * obj_val, const rb_str_t * key)
{
    if (!obj_val || !key || obj_val->size < 1 || obj_val->capacity < 1)
    {
        return NULL;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        uint32_pair_t * item = obj_val->arr + i;
        if (rb_eq_string(key, &item->key))
        {
            return item;
        }
    }
    return NULL;
}

rb_bool_t rb_uint32_dict_set_item(const rb_str_t * key, const uint32_t * val, uint32_dict_t * obj_val)
{
    if (!key || !val || !obj_val || !obj_val->arr || obj_val->size >= obj_val->capacity)
    {
        return false;
    }
    uint32_pair_t * it = rb_uint32_dict_get_item(obj_val, key);
    if (it)
    {
        rb_dispose_uint32(&it->val);
        return rb_set_uint32(val, &it->val);
    }
    it = obj_val->arr + obj_val->size;
    if (!rb_set_string(key, &it->key))
    {
        return false;
    }
    if (!rb_set_uint32(val, &it->val))
    {
        rb_dispose_string(&it->key);
        return false;
    }
    ++obj_val->size;
    return false;
}

void rb_init_uint32_dict(uint32_dict_t * obj_val)
{
    if (!obj_val || !obj_val->arr || obj_val->capacity < 1)
    {
        return;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->capacity; ++i)
    {
        uint32_pair_t * it = obj_val->arr + i;
        rb_init_string(&it->key);
        rb_init_uint32(&it->val);
    }
}

rb_bool_t rb_set_uint32_dict(const uint32_dict_t * src, uint32_dict_t * dst)
{
    if(!src || !src->arr || !dst)
    {
        return false;
    }
    if (src->size < 1)
    {
        memset(dst, 0, sizeof(uint32_dict_t));
        return true;
    }
    *dst = rb_create_uint32_dict(src->size);
    dst->size = src->size;
    rb_size_t i = 0;
    for (i = 0; i < dst->size; ++i)
    {
        uint32_pair_t * it_src = src->arr + i;
        uint32_pair_t * it_dst = dst->arr + i;
        if (!rb_set_string(&it_src->key, &it_dst->key))
        {
            rb_dispose_uint32_dict(dst);
            return false;
        }
        if (!rb_set_uint32(&it_src->val, &it_dst->val))
        {
            rb_dispose_uint32_dict(dst);
            return false;
        }
    }
    return true;
}

rb_bool_t rb_eq_uint32_dict(const uint32_dict_t * src, const uint32_dict_t * dst)
{
    if(!src || !dst)
    {
        return false;
    }
    if (!src->arr && !dst->arr)
    {
        return true;
    }
    if(!src->arr || !dst->arr || (src->size != dst->size))
    {
        return false;
    }
    rb_size_t i = 0;
    for (i = 0; i < src->size; ++i)
    {
        uint32_pair_t * it_src = src->arr + i;
        uint32_pair_t * it_dst = dst->arr + i;
        if (!rb_eq_string(&it_src->key, &it_dst->key))
        {
            return false;
        }
        if (!rb_eq_uint32(&it_src->val, &it_dst->val))
        {
            return false;
        }
    }
    return true;
}

void rb_dispose_uint32_dict(uint32_dict_t * obj_val)
{
    if (!obj_val || !obj_val->arr)
    {
        return;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        uint32_pair_t * it = obj_val->arr + i;
        rb_dispose_string(&it->key);
        rb_dispose_uint32(&it->val);
    }
    rb_free(obj_val->arr);
    memset(obj_val, 0, sizeof(uint32_dict_t));
}

rb_size_t rb_sizeof_uint32_dict(const uint32_dict_t * obj_val)
{
    rb_size_t size = sizeof(rb_size_t) + obj_val->size * sizeof(rb_size_t);
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        uint32_pair_t * it = obj_val->arr + i;
        size += rb_sizeof_string(&it->key);
        size += rb_sizeof_uint32(&it->val);
    }
    return size;
}

rb_bool_t rb_encode_uint32_dict(const uint32_dict_t * obj_val, rb_buf_t * rb_val)
{
    if (!obj_val || !obj_val->arr)
    {
        return false;
    }
    rb_buf_t buf = rb_nested_buf(rb_val, 0);
    if (buf.size < 1)
    {
        return false;
    }
    if (!rb_set_array_count(obj_val->size, &buf))
    {
        return false;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        if (!rb_set_array_table_item(i, buf.pos - buf.start, &buf))
        {
            return false;
        }
        uint32_pair_t * it = obj_val->arr + i;
        if (!rb_encode_string(&it->key, &buf))
        {
            return false;
        }
        if (!rb_encode_uint32(&it->val, &buf))
        {
            return false;
        }
    }
    rb_val->pos = buf.pos;
    return true;
}

rb_bool_t rb_decode_uint32_dict(const rb_buf_t * rb_val, rb_offset_t offset, uint32_dict_t * obj_val)
{
    if (!obj_val)
    {
        return false;
    }
    rb_buf_t buf = rb_nested_buf(rb_val, offset);
    if (buf.size < 1)
    {
        return false;
    }
    rb_size_t size = rb_get_array_count(&buf);
    if (size < 1)
    {
        memset(obj_val, 0, sizeof(uint32_dict_t));
        return true;
    }

    *obj_val = rb_create_uint32_dict(size);
    obj_val->size = size;

    rb_bool_t rc = true;
    rb_offset_t off = 0;
    rb_size_t i = 0;
    for (i = 0; i < size; ++i)
    {
        if (!rb_get_array_table_item(i, &buf, &off))
        {
            rc = false;
            break;
        }
        uint32_pair_t * it = obj_val->arr + i;
        if (!rb_decode_string(&buf, off, &it->key))
        {
            rc = false;
            break;
        }
        rb_offset_t delta = rb_sizeof_string(&it->key);
        if (!rb_decode_uint32(&buf, off + delta, &it->val))
        {
            rc = false;
            break;
        }
    }
    if (!rc)
    {
        rb_dispose_uint32_dict(obj_val);
    }
    return rc;
}

int64_dict_t rb_create_int64_dict(rb_size_t capacity)
{
    int64_dict_t obj_val = { capacity, 0, 0 };
    if (capacity > 0)
    {
        rb_size_t len = capacity * sizeof(int64_pair_t);
        obj_val.arr = (int64_pair_t *) rb_malloc(len);
        memset(obj_val.arr, 0, len);
        rb_size_t i = 0;
        for (i = 0; i < capacity; ++i)
        {
            rb_init_string(&(obj_val.arr + i)->key);
            rb_init_int64(&(obj_val.arr + i)->val);
        }
    }
    return obj_val;
}

int64_pair_t * rb_int64_dict_get_item(const int64_dict_t * obj_val, const rb_str_t * key)
{
    if (!obj_val || !key || obj_val->size < 1 || obj_val->capacity < 1)
    {
        return NULL;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        int64_pair_t * item = obj_val->arr + i;
        if (rb_eq_string(key, &item->key))
        {
            return item;
        }
    }
    return NULL;
}

rb_bool_t rb_int64_dict_set_item(const rb_str_t * key, const int64_t * val, int64_dict_t * obj_val)
{
    if (!key || !val || !obj_val || !obj_val->arr || obj_val->size >= obj_val->capacity)
    {
        return false;
    }
    int64_pair_t * it = rb_int64_dict_get_item(obj_val, key);
    if (it)
    {
        rb_dispose_int64(&it->val);
        return rb_set_int64(val, &it->val);
    }
    it = obj_val->arr + obj_val->size;
    if (!rb_set_string(key, &it->key))
    {
        return false;
    }
    if (!rb_set_int64(val, &it->val))
    {
        rb_dispose_string(&it->key);
        return false;
    }
    ++obj_val->size;
    return false;
}

void rb_init_int64_dict(int64_dict_t * obj_val)
{
    if (!obj_val || !obj_val->arr || obj_val->capacity < 1)
    {
        return;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->capacity; ++i)
    {
        int64_pair_t * it = obj_val->arr + i;
        rb_init_string(&it->key);
        rb_init_int64(&it->val);
    }
}

rb_bool_t rb_set_int64_dict(const int64_dict_t * src, int64_dict_t * dst)
{
    if(!src || !src->arr || !dst)
    {
        return false;
    }
    if (src->size < 1)
    {
        memset(dst, 0, sizeof(int64_dict_t));
        return true;
    }
    *dst = rb_create_int64_dict(src->size);
    dst->size = src->size;
    rb_size_t i = 0;
    for (i = 0; i < dst->size; ++i)
    {
        int64_pair_t * it_src = src->arr + i;
        int64_pair_t * it_dst = dst->arr + i;
        if (!rb_set_string(&it_src->key, &it_dst->key))
        {
            rb_dispose_int64_dict(dst);
            return false;
        }
        if (!rb_set_int64(&it_src->val, &it_dst->val))
        {
            rb_dispose_int64_dict(dst);
            return false;
        }
    }
    return true;
}

rb_bool_t rb_eq_int64_dict(const int64_dict_t * src, const int64_dict_t * dst)
{
    if(!src || !dst)
    {
        return false;
    }
    if (!src->arr && !dst->arr)
    {
        return true;
    }
    if(!src->arr || !dst->arr || (src->size != dst->size))
    {
        return false;
    }
    rb_size_t i = 0;
    for (i = 0; i < src->size; ++i)
    {
        int64_pair_t * it_src = src->arr + i;
        int64_pair_t * it_dst = dst->arr + i;
        if (!rb_eq_string(&it_src->key, &it_dst->key))
        {
            return false;
        }
        if (!rb_eq_int64(&it_src->val, &it_dst->val))
        {
            return false;
        }
    }
    return true;
}

void rb_dispose_int64_dict(int64_dict_t * obj_val)
{
    if (!obj_val || !obj_val->arr)
    {
        return;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        int64_pair_t * it = obj_val->arr + i;
        rb_dispose_string(&it->key);
        rb_dispose_int64(&it->val);
    }
    rb_free(obj_val->arr);
    memset(obj_val, 0, sizeof(int64_dict_t));
}

rb_size_t rb_sizeof_int64_dict(const int64_dict_t * obj_val)
{
    rb_size_t size = sizeof(rb_size_t) + obj_val->size * sizeof(rb_size_t);
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        int64_pair_t * it = obj_val->arr + i;
        size += rb_sizeof_string(&it->key);
        size += rb_sizeof_int64(&it->val);
    }
    return size;
}

rb_bool_t rb_encode_int64_dict(const int64_dict_t * obj_val, rb_buf_t * rb_val)
{
    if (!obj_val || !obj_val->arr)
    {
        return false;
    }
    rb_buf_t buf = rb_nested_buf(rb_val, 0);
    if (buf.size < 1)
    {
        return false;
    }
    if (!rb_set_array_count(obj_val->size, &buf))
    {
        return false;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        if (!rb_set_array_table_item(i, buf.pos - buf.start, &buf))
        {
            return false;
        }
        int64_pair_t * it = obj_val->arr + i;
        if (!rb_encode_string(&it->key, &buf))
        {
            return false;
        }
        if (!rb_encode_int64(&it->val, &buf))
        {
            return false;
        }
    }
    rb_val->pos = buf.pos;
    return true;
}

rb_bool_t rb_decode_int64_dict(const rb_buf_t * rb_val, rb_offset_t offset, int64_dict_t * obj_val)
{
    if (!obj_val)
    {
        return false;
    }
    rb_buf_t buf = rb_nested_buf(rb_val, offset);
    if (buf.size < 1)
    {
        return false;
    }
    rb_size_t size = rb_get_array_count(&buf);
    if (size < 1)
    {
        memset(obj_val, 0, sizeof(int64_dict_t));
        return true;
    }

    *obj_val = rb_create_int64_dict(size);
    obj_val->size = size;

    rb_bool_t rc = true;
    rb_offset_t off = 0;
    rb_size_t i = 0;
    for (i = 0; i < size; ++i)
    {
        if (!rb_get_array_table_item(i, &buf, &off))
        {
            rc = false;
            break;
        }
        int64_pair_t * it = obj_val->arr + i;
        if (!rb_decode_string(&buf, off, &it->key))
        {
            rc = false;
            break;
        }
        rb_offset_t delta = rb_sizeof_string(&it->key);
        if (!rb_decode_int64(&buf, off + delta, &it->val))
        {
            rc = false;
            break;
        }
    }
    if (!rc)
    {
        rb_dispose_int64_dict(obj_val);
    }
    return rc;
}

uint64_dict_t rb_create_uint64_dict(rb_size_t capacity)
{
    uint64_dict_t obj_val = { capacity, 0, 0 };
    if (capacity > 0)
    {
        rb_size_t len = capacity * sizeof(uint64_pair_t);
        obj_val.arr = (uint64_pair_t *) rb_malloc(len);
        memset(obj_val.arr, 0, len);
        rb_size_t i = 0;
        for (i = 0; i < capacity; ++i)
        {
            rb_init_string(&(obj_val.arr + i)->key);
            rb_init_uint64(&(obj_val.arr + i)->val);
        }
    }
    return obj_val;
}

uint64_pair_t * rb_uint64_dict_get_item(const uint64_dict_t * obj_val, const rb_str_t * key)
{
    if (!obj_val || !key || obj_val->size < 1 || obj_val->capacity < 1)
    {
        return NULL;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        uint64_pair_t * item = obj_val->arr + i;
        if (rb_eq_string(key, &item->key))
        {
            return item;
        }
    }
    return NULL;
}

rb_bool_t rb_uint64_dict_set_item(const rb_str_t * key, const uint64_t * val, uint64_dict_t * obj_val)
{
    if (!key || !val || !obj_val || !obj_val->arr || obj_val->size >= obj_val->capacity)
    {
        return false;
    }
    uint64_pair_t * it = rb_uint64_dict_get_item(obj_val, key);
    if (it)
    {
        rb_dispose_uint64(&it->val);
        return rb_set_uint64(val, &it->val);
    }
    it = obj_val->arr + obj_val->size;
    if (!rb_set_string(key, &it->key))
    {
        return false;
    }
    if (!rb_set_uint64(val, &it->val))
    {
        rb_dispose_string(&it->key);
        return false;
    }
    ++obj_val->size;
    return false;
}

void rb_init_uint64_dict(uint64_dict_t * obj_val)
{
    if (!obj_val || !obj_val->arr || obj_val->capacity < 1)
    {
        return;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->capacity; ++i)
    {
        uint64_pair_t * it = obj_val->arr + i;
        rb_init_string(&it->key);
        rb_init_uint64(&it->val);
    }
}

rb_bool_t rb_set_uint64_dict(const uint64_dict_t * src, uint64_dict_t * dst)
{
    if(!src || !src->arr || !dst)
    {
        return false;
    }
    if (src->size < 1)
    {
        memset(dst, 0, sizeof(uint64_dict_t));
        return true;
    }
    *dst = rb_create_uint64_dict(src->size);
    dst->size = src->size;
    rb_size_t i = 0;
    for (i = 0; i < dst->size; ++i)
    {
        uint64_pair_t * it_src = src->arr + i;
        uint64_pair_t * it_dst = dst->arr + i;
        if (!rb_set_string(&it_src->key, &it_dst->key))
        {
            rb_dispose_uint64_dict(dst);
            return false;
        }
        if (!rb_set_uint64(&it_src->val, &it_dst->val))
        {
            rb_dispose_uint64_dict(dst);
            return false;
        }
    }
    return true;
}

rb_bool_t rb_eq_uint64_dict(const uint64_dict_t * src, const uint64_dict_t * dst)
{
    if(!src || !dst)
    {
        return false;
    }
    if (!src->arr && !dst->arr)
    {
        return true;
    }
    if(!src->arr || !dst->arr || (src->size != dst->size))
    {
        return false;
    }
    rb_size_t i = 0;
    for (i = 0; i < src->size; ++i)
    {
        uint64_pair_t * it_src = src->arr + i;
        uint64_pair_t * it_dst = dst->arr + i;
        if (!rb_eq_string(&it_src->key, &it_dst->key))
        {
            return false;
        }
        if (!rb_eq_uint64(&it_src->val, &it_dst->val))
        {
            return false;
        }
    }
    return true;
}

void rb_dispose_uint64_dict(uint64_dict_t * obj_val)
{
    if (!obj_val || !obj_val->arr)
    {
        return;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        uint64_pair_t * it = obj_val->arr + i;
        rb_dispose_string(&it->key);
        rb_dispose_uint64(&it->val);
    }
    rb_free(obj_val->arr);
    memset(obj_val, 0, sizeof(uint64_dict_t));
}

rb_size_t rb_sizeof_uint64_dict(const uint64_dict_t * obj_val)
{
    rb_size_t size = sizeof(rb_size_t) + obj_val->size * sizeof(rb_size_t);
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        uint64_pair_t * it = obj_val->arr + i;
        size += rb_sizeof_string(&it->key);
        size += rb_sizeof_uint64(&it->val);
    }
    return size;
}

rb_bool_t rb_encode_uint64_dict(const uint64_dict_t * obj_val, rb_buf_t * rb_val)
{
    if (!obj_val || !obj_val->arr)
    {
        return false;
    }
    rb_buf_t buf = rb_nested_buf(rb_val, 0);
    if (buf.size < 1)
    {
        return false;
    }
    if (!rb_set_array_count(obj_val->size, &buf))
    {
        return false;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        if (!rb_set_array_table_item(i, buf.pos - buf.start, &buf))
        {
            return false;
        }
        uint64_pair_t * it = obj_val->arr + i;
        if (!rb_encode_string(&it->key, &buf))
        {
            return false;
        }
        if (!rb_encode_uint64(&it->val, &buf))
        {
            return false;
        }
    }
    rb_val->pos = buf.pos;
    return true;
}

rb_bool_t rb_decode_uint64_dict(const rb_buf_t * rb_val, rb_offset_t offset, uint64_dict_t * obj_val)
{
    if (!obj_val)
    {
        return false;
    }
    rb_buf_t buf = rb_nested_buf(rb_val, offset);
    if (buf.size < 1)
    {
        return false;
    }
    rb_size_t size = rb_get_array_count(&buf);
    if (size < 1)
    {
        memset(obj_val, 0, sizeof(uint64_dict_t));
        return true;
    }

    *obj_val = rb_create_uint64_dict(size);
    obj_val->size = size;

    rb_bool_t rc = true;
    rb_offset_t off = 0;
    rb_size_t i = 0;
    for (i = 0; i < size; ++i)
    {
        if (!rb_get_array_table_item(i, &buf, &off))
        {
            rc = false;
            break;
        }
        uint64_pair_t * it = obj_val->arr + i;
        if (!rb_decode_string(&buf, off, &it->key))
        {
            rc = false;
            break;
        }
        rb_offset_t delta = rb_sizeof_string(&it->key);
        if (!rb_decode_uint64(&buf, off + delta, &it->val))
        {
            rc = false;
            break;
        }
    }
    if (!rc)
    {
        rb_dispose_uint64_dict(obj_val);
    }
    return rc;
}

float_dict_t rb_create_float_dict(rb_size_t capacity)
{
    float_dict_t obj_val = { capacity, 0, 0 };
    if (capacity > 0)
    {
        rb_size_t len = capacity * sizeof(float_pair_t);
        obj_val.arr = (float_pair_t *) rb_malloc(len);
        memset(obj_val.arr, 0, len);
        rb_size_t i = 0;
        for (i = 0; i < capacity; ++i)
        {
            rb_init_string(&(obj_val.arr + i)->key);
            rb_init_float(&(obj_val.arr + i)->val);
        }
    }
    return obj_val;
}

float_pair_t * rb_float_dict_get_item(const float_dict_t * obj_val, const rb_str_t * key)
{
    if (!obj_val || !key || obj_val->size < 1 || obj_val->capacity < 1)
    {
        return NULL;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        float_pair_t * item = obj_val->arr + i;
        if (rb_eq_string(key, &item->key))
        {
            return item;
        }
    }
    return NULL;
}

rb_bool_t rb_float_dict_set_item(const rb_str_t * key, const float * val, float_dict_t * obj_val)
{
    if (!key || !val || !obj_val || !obj_val->arr || obj_val->size >= obj_val->capacity)
    {
        return false;
    }
    float_pair_t * it = rb_float_dict_get_item(obj_val, key);
    if (it)
    {
        rb_dispose_float(&it->val);
        return rb_set_float(val, &it->val);
    }
    it = obj_val->arr + obj_val->size;
    if (!rb_set_string(key, &it->key))
    {
        return false;
    }
    if (!rb_set_float(val, &it->val))
    {
        rb_dispose_string(&it->key);
        return false;
    }
    ++obj_val->size;
    return false;
}

void rb_init_float_dict(float_dict_t * obj_val)
{
    if (!obj_val || !obj_val->arr || obj_val->capacity < 1)
    {
        return;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->capacity; ++i)
    {
        float_pair_t * it = obj_val->arr + i;
        rb_init_string(&it->key);
        rb_init_float(&it->val);
    }
}

rb_bool_t rb_set_float_dict(const float_dict_t * src, float_dict_t * dst)
{
    if(!src || !src->arr || !dst)
    {
        return false;
    }
    if (src->size < 1)
    {
        memset(dst, 0, sizeof(float_dict_t));
        return true;
    }
    *dst = rb_create_float_dict(src->size);
    dst->size = src->size;
    rb_size_t i = 0;
    for (i = 0; i < dst->size; ++i)
    {
        float_pair_t * it_src = src->arr + i;
        float_pair_t * it_dst = dst->arr + i;
        if (!rb_set_string(&it_src->key, &it_dst->key))
        {
            rb_dispose_float_dict(dst);
            return false;
        }
        if (!rb_set_float(&it_src->val, &it_dst->val))
        {
            rb_dispose_float_dict(dst);
            return false;
        }
    }
    return true;
}

rb_bool_t rb_eq_float_dict(const float_dict_t * src, const float_dict_t * dst)
{
    if(!src || !dst)
    {
        return false;
    }
    if (!src->arr && !dst->arr)
    {
        return true;
    }
    if(!src->arr || !dst->arr || (src->size != dst->size))
    {
        return false;
    }
    rb_size_t i = 0;
    for (i = 0; i < src->size; ++i)
    {
        float_pair_t * it_src = src->arr + i;
        float_pair_t * it_dst = dst->arr + i;
        if (!rb_eq_string(&it_src->key, &it_dst->key))
        {
            return false;
        }
        if (!rb_eq_float(&it_src->val, &it_dst->val))
        {
            return false;
        }
    }
    return true;
}

void rb_dispose_float_dict(float_dict_t * obj_val)
{
    if (!obj_val || !obj_val->arr)
    {
        return;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        float_pair_t * it = obj_val->arr + i;
        rb_dispose_string(&it->key);
        rb_dispose_float(&it->val);
    }
    rb_free(obj_val->arr);
    memset(obj_val, 0, sizeof(float_dict_t));
}

rb_size_t rb_sizeof_float_dict(const float_dict_t * obj_val)
{
    rb_size_t size = sizeof(rb_size_t) + obj_val->size * sizeof(rb_size_t);
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        float_pair_t * it = obj_val->arr + i;
        size += rb_sizeof_string(&it->key);
        size += rb_sizeof_float(&it->val);
    }
    return size;
}

rb_bool_t rb_encode_float_dict(const float_dict_t * obj_val, rb_buf_t * rb_val)
{
    if (!obj_val || !obj_val->arr)
    {
        return false;
    }
    rb_buf_t buf = rb_nested_buf(rb_val, 0);
    if (buf.size < 1)
    {
        return false;
    }
    if (!rb_set_array_count(obj_val->size, &buf))
    {
        return false;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        if (!rb_set_array_table_item(i, buf.pos - buf.start, &buf))
        {
            return false;
        }
        float_pair_t * it = obj_val->arr + i;
        if (!rb_encode_string(&it->key, &buf))
        {
            return false;
        }
        if (!rb_encode_float(&it->val, &buf))
        {
            return false;
        }
    }
    rb_val->pos = buf.pos;
    return true;
}

rb_bool_t rb_decode_float_dict(const rb_buf_t * rb_val, rb_offset_t offset, float_dict_t * obj_val)
{
    if (!obj_val)
    {
        return false;
    }
    rb_buf_t buf = rb_nested_buf(rb_val, offset);
    if (buf.size < 1)
    {
        return false;
    }
    rb_size_t size = rb_get_array_count(&buf);
    if (size < 1)
    {
        memset(obj_val, 0, sizeof(float_dict_t));
        return true;
    }

    *obj_val = rb_create_float_dict(size);
    obj_val->size = size;

    rb_bool_t rc = true;
    rb_offset_t off = 0;
    rb_size_t i = 0;
    for (i = 0; i < size; ++i)
    {
        if (!rb_get_array_table_item(i, &buf, &off))
        {
            rc = false;
            break;
        }
        float_pair_t * it = obj_val->arr + i;
        if (!rb_decode_string(&buf, off, &it->key))
        {
            rc = false;
            break;
        }
        rb_offset_t delta = rb_sizeof_string(&it->key);
        if (!rb_decode_float(&buf, off + delta, &it->val))
        {
            rc = false;
            break;
        }
    }
    if (!rc)
    {
        rb_dispose_float_dict(obj_val);
    }
    return rc;
}

double_dict_t rb_create_double_dict(rb_size_t capacity)
{
    double_dict_t obj_val = { capacity, 0, 0 };
    if (capacity > 0)
    {
        rb_size_t len = capacity * sizeof(double_pair_t);
        obj_val.arr = (double_pair_t *) rb_malloc(len);
        memset(obj_val.arr, 0, len);
        rb_size_t i = 0;
        for (i = 0; i < capacity; ++i)
        {
            rb_init_string(&(obj_val.arr + i)->key);
            rb_init_double(&(obj_val.arr + i)->val);
        }
    }
    return obj_val;
}

double_pair_t * rb_double_dict_get_item(const double_dict_t * obj_val, const rb_str_t * key)
{
    if (!obj_val || !key || obj_val->size < 1 || obj_val->capacity < 1)
    {
        return NULL;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        double_pair_t * item = obj_val->arr + i;
        if (rb_eq_string(key, &item->key))
        {
            return item;
        }
    }
    return NULL;
}

rb_bool_t rb_double_dict_set_item(const rb_str_t * key, const double * val, double_dict_t * obj_val)
{
    if (!key || !val || !obj_val || !obj_val->arr || obj_val->size >= obj_val->capacity)
    {
        return false;
    }
    double_pair_t * it = rb_double_dict_get_item(obj_val, key);
    if (it)
    {
        rb_dispose_double(&it->val);
        return rb_set_double(val, &it->val);
    }
    it = obj_val->arr + obj_val->size;
    if (!rb_set_string(key, &it->key))
    {
        return false;
    }
    if (!rb_set_double(val, &it->val))
    {
        rb_dispose_string(&it->key);
        return false;
    }
    ++obj_val->size;
    return false;
}

void rb_init_double_dict(double_dict_t * obj_val)
{
    if (!obj_val || !obj_val->arr || obj_val->capacity < 1)
    {
        return;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->capacity; ++i)
    {
        double_pair_t * it = obj_val->arr + i;
        rb_init_string(&it->key);
        rb_init_double(&it->val);
    }
}

rb_bool_t rb_set_double_dict(const double_dict_t * src, double_dict_t * dst)
{
    if(!src || !src->arr || !dst)
    {
        return false;
    }
    if (src->size < 1)
    {
        memset(dst, 0, sizeof(double_dict_t));
        return true;
    }
    *dst = rb_create_double_dict(src->size);
    dst->size = src->size;
    rb_size_t i = 0;
    for (i = 0; i < dst->size; ++i)
    {
        double_pair_t * it_src = src->arr + i;
        double_pair_t * it_dst = dst->arr + i;
        if (!rb_set_string(&it_src->key, &it_dst->key))
        {
            rb_dispose_double_dict(dst);
            return false;
        }
        if (!rb_set_double(&it_src->val, &it_dst->val))
        {
            rb_dispose_double_dict(dst);
            return false;
        }
    }
    return true;
}

rb_bool_t rb_eq_double_dict(const double_dict_t * src, const double_dict_t * dst)
{
    if(!src || !dst)
    {
        return false;
    }
    if (!src->arr && !dst->arr)
    {
        return true;
    }
    if(!src->arr || !dst->arr || (src->size != dst->size))
    {
        return false;
    }
    rb_size_t i = 0;
    for (i = 0; i < src->size; ++i)
    {
        double_pair_t * it_src = src->arr + i;
        double_pair_t * it_dst = dst->arr + i;
        if (!rb_eq_string(&it_src->key, &it_dst->key))
        {
            return false;
        }
        if (!rb_eq_double(&it_src->val, &it_dst->val))
        {
            return false;
        }
    }
    return true;
}

void rb_dispose_double_dict(double_dict_t * obj_val)
{
    if (!obj_val || !obj_val->arr)
    {
        return;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        double_pair_t * it = obj_val->arr + i;
        rb_dispose_string(&it->key);
        rb_dispose_double(&it->val);
    }
    rb_free(obj_val->arr);
    memset(obj_val, 0, sizeof(double_dict_t));
}

rb_size_t rb_sizeof_double_dict(const double_dict_t * obj_val)
{
    rb_size_t size = sizeof(rb_size_t) + obj_val->size * sizeof(rb_size_t);
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        double_pair_t * it = obj_val->arr + i;
        size += rb_sizeof_string(&it->key);
        size += rb_sizeof_double(&it->val);
    }
    return size;
}

rb_bool_t rb_encode_double_dict(const double_dict_t * obj_val, rb_buf_t * rb_val)
{
    if (!obj_val || !obj_val->arr)
    {
        return false;
    }
    rb_buf_t buf = rb_nested_buf(rb_val, 0);
    if (buf.size < 1)
    {
        return false;
    }
    if (!rb_set_array_count(obj_val->size, &buf))
    {
        return false;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        if (!rb_set_array_table_item(i, buf.pos - buf.start, &buf))
        {
            return false;
        }
        double_pair_t * it = obj_val->arr + i;
        if (!rb_encode_string(&it->key, &buf))
        {
            return false;
        }
        if (!rb_encode_double(&it->val, &buf))
        {
            return false;
        }
    }
    rb_val->pos = buf.pos;
    return true;
}

rb_bool_t rb_decode_double_dict(const rb_buf_t * rb_val, rb_offset_t offset, double_dict_t * obj_val)
{
    if (!obj_val)
    {
        return false;
    }
    rb_buf_t buf = rb_nested_buf(rb_val, offset);
    if (buf.size < 1)
    {
        return false;
    }
    rb_size_t size = rb_get_array_count(&buf);
    if (size < 1)
    {
        memset(obj_val, 0, sizeof(double_dict_t));
        return true;
    }

    *obj_val = rb_create_double_dict(size);
    obj_val->size = size;

    rb_bool_t rc = true;
    rb_offset_t off = 0;
    rb_size_t i = 0;
    for (i = 0; i < size; ++i)
    {
        if (!rb_get_array_table_item(i, &buf, &off))
        {
            rc = false;
            break;
        }
        double_pair_t * it = obj_val->arr + i;
        if (!rb_decode_string(&buf, off, &it->key))
        {
            rc = false;
            break;
        }
        rb_offset_t delta = rb_sizeof_string(&it->key);
        if (!rb_decode_double(&buf, off + delta, &it->val))
        {
            rc = false;
            break;
        }
    }
    if (!rc)
    {
        rb_dispose_double_dict(obj_val);
    }
    return rc;
}

string_dict_t rb_create_string_dict(rb_size_t capacity)
{
    string_dict_t obj_val = { capacity, 0, 0 };
    if (capacity > 0)
    {
        rb_size_t len = capacity * sizeof(string_pair_t);
        obj_val.arr = (string_pair_t *) rb_malloc(len);
        memset(obj_val.arr, 0, len);
        rb_size_t i = 0;
        for (i = 0; i < capacity; ++i)
        {
            rb_init_string(&(obj_val.arr + i)->key);
            rb_init_string(&(obj_val.arr + i)->val);
        }
    }
    return obj_val;
}

string_pair_t * rb_string_dict_get_item(const string_dict_t * obj_val, const rb_str_t * key)
{
    if (!obj_val || !key || obj_val->size < 1 || obj_val->capacity < 1)
    {
        return NULL;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        string_pair_t * item = obj_val->arr + i;
        if (rb_eq_string(key, &item->key))
        {
            return item;
        }
    }
    return NULL;
}

rb_bool_t rb_string_dict_set_item(const rb_str_t * key, const rb_str_t * val, string_dict_t * obj_val)
{
    if (!key || !val || !obj_val || !obj_val->arr || obj_val->size >= obj_val->capacity)
    {
        return false;
    }
    string_pair_t * it = rb_string_dict_get_item(obj_val, key);
    if (it)
    {
        rb_dispose_string(&it->val);
        return rb_set_string(val, &it->val);
    }
    it = obj_val->arr + obj_val->size;
    if (!rb_set_string(key, &it->key))
    {
        return false;
    }
    if (!rb_set_string(val, &it->val))
    {
        rb_dispose_string(&it->key);
        return false;
    }
    ++obj_val->size;
    return false;
}

void rb_init_string_dict(string_dict_t * obj_val)
{
    if (!obj_val || !obj_val->arr || obj_val->capacity < 1)
    {
        return;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->capacity; ++i)
    {
        string_pair_t * it = obj_val->arr + i;
        rb_init_string(&it->key);
        rb_init_string(&it->val);
    }
}

rb_bool_t rb_set_string_dict(const string_dict_t * src, string_dict_t * dst)
{
    if(!src || !src->arr || !dst)
    {
        return false;
    }
    if (src->size < 1)
    {
        memset(dst, 0, sizeof(string_dict_t));
        return true;
    }
    *dst = rb_create_string_dict(src->size);
    dst->size = src->size;
    rb_size_t i = 0;
    for (i = 0; i < dst->size; ++i)
    {
        string_pair_t * it_src = src->arr + i;
        string_pair_t * it_dst = dst->arr + i;
        if (!rb_set_string(&it_src->key, &it_dst->key))
        {
            rb_dispose_string_dict(dst);
            return false;
        }
        if (!rb_set_string(&it_src->val, &it_dst->val))
        {
            rb_dispose_string_dict(dst);
            return false;
        }
    }
    return true;
}

rb_bool_t rb_eq_string_dict(const string_dict_t * src, const string_dict_t * dst)
{
    if(!src || !dst)
    {
        return false;
    }
    if (!src->arr && !dst->arr)
    {
        return true;
    }
    if(!src->arr || !dst->arr || (src->size != dst->size))
    {
        return false;
    }
    rb_size_t i = 0;
    for (i = 0; i < src->size; ++i)
    {
        string_pair_t * it_src = src->arr + i;
        string_pair_t * it_dst = dst->arr + i;
        if (!rb_eq_string(&it_src->key, &it_dst->key))
        {
            return false;
        }
        if (!rb_eq_string(&it_src->val, &it_dst->val))
        {
            return false;
        }
    }
    return true;
}

void rb_dispose_string_dict(string_dict_t * obj_val)
{
    if (!obj_val || !obj_val->arr)
    {
        return;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        string_pair_t * it = obj_val->arr + i;
        rb_dispose_string(&it->key);
        rb_dispose_string(&it->val);
    }
    rb_free(obj_val->arr);
    memset(obj_val, 0, sizeof(string_dict_t));
}

rb_size_t rb_sizeof_string_dict(const string_dict_t * obj_val)
{
    rb_size_t size = sizeof(rb_size_t) + obj_val->size * sizeof(rb_size_t);
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        string_pair_t * it = obj_val->arr + i;
        size += rb_sizeof_string(&it->key);
        size += rb_sizeof_string(&it->val);
    }
    return size;
}

rb_bool_t rb_encode_string_dict(const string_dict_t * obj_val, rb_buf_t * rb_val)
{
    if (!obj_val || !obj_val->arr)
    {
        return false;
    }
    rb_buf_t buf = rb_nested_buf(rb_val, 0);
    if (buf.size < 1)
    {
        return false;
    }
    if (!rb_set_array_count(obj_val->size, &buf))
    {
        return false;
    }
    rb_size_t i = 0;
    for (i = 0; i < obj_val->size; ++i)
    {
        if (!rb_set_array_table_item(i, buf.pos - buf.start, &buf))
        {
            return false;
        }
        string_pair_t * it = obj_val->arr + i;
        if (!rb_encode_string(&it->key, &buf))
        {
            return false;
        }
        if (!rb_encode_string(&it->val, &buf))
        {
            return false;
        }
    }
    rb_val->pos = buf.pos;
    return true;
}

rb_bool_t rb_decode_string_dict(const rb_buf_t * rb_val, rb_offset_t offset, string_dict_t * obj_val)
{
    if (!obj_val)
    {
        return false;
    }
    rb_buf_t buf = rb_nested_buf(rb_val, offset);
    if (buf.size < 1)
    {
        return false;
    }
    rb_size_t size = rb_get_array_count(&buf);
    if (size < 1)
    {
        memset(obj_val, 0, sizeof(string_dict_t));
        return true;
    }

    *obj_val = rb_create_string_dict(size);
    obj_val->size = size;

    rb_bool_t rc = true;
    rb_offset_t off = 0;
    rb_size_t i = 0;
    for (i = 0; i < size; ++i)
    {
        if (!rb_get_array_table_item(i, &buf, &off))
        {
            rc = false;
            break;
        }
        string_pair_t * it = obj_val->arr + i;
        if (!rb_decode_string(&buf, off, &it->key))
        {
            rc = false;
            break;
        }
        rb_offset_t delta = rb_sizeof_string(&it->key);
        if (!rb_decode_string(&buf, off + delta, &it->val))
        {
            rc = false;
            break;
        }
    }
    if (!rc)
    {
        rb_dispose_string_dict(obj_val);
    }
    return rc;
}

