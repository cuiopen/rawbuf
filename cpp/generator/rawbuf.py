#!/usr/bin/python
#author: jobs
#email: yao050421103@gmail.com
import sys
import os.path
import datetime
import string
import json

CTYPE = 0
NAME = 1
ID = 2

FILTER = '@null_string_place_holder'
merge = lambda l: string.join(filter(lambda item: FILTER != item, l), '\n')
json_filter = lambda f: (lambda f, l: os.path.splitext(f)[1] in l)(f, ['.json'])
parse_key = lambda ctype: ctype[:(len(ctype) - len('_t'))] if ctype.endswith('_t') else ctype

def manual(): 
    print """
    usage:
        python rawbuf.py [option] filelist
            [option]
                -f: use file in filelist
                -p: use dir in filelist, will be parsed recursive
                
    sample:
        python rawbuf.py -f file1.json file2.json file3.json
        python rawbuf.py -p ./dir1/ ./dir2/ ./dir3/
        """

def get_file_list(cur_dir, path_filter):
    def __get(cur_dir, path_filter, file_list):
        for root, dirs, files in os.walk(cur_dir): 
            for f in files:
                if path_filter(f):
                    file_list.append(os.path.join(root, f))
    file_list = []
    __get(cur_dir, path_filter, file_list)
    return file_list

def get_files(file_filter, op, urls):
    if '-f' == op:
        return filter(file_filter, urls)
    elif '-p' == op:
        file_set = set()
        for url in urls:
            for item in get_file_list(url, file_filter):
                if not item in file_set:
                    file_set.add(item)
        return list(file_set)
    return []

def write_file(url, data):
    with open(url, 'w') as f:
        f.writelines(data)

def get_scalar_dict():
    return {
        'bool': 'false',
        'int8_t': '0',
        'uint8_t': '0',
        'short': '0',
        'int16_t': '0',
        'uint16_t': '0',
        'int': '0',
        'int32_t': '0',
        'uint32_t': '0',
        'long': '0',
        'int64_t': '0',
        'uint64_t': '0',
        'float': '0.0',
        'double': '0.0'
        }

def write_interface(path, header, details):
    tm = datetime.datetime.now().strftime('%Y%m%d%H%M%S')
    head_def = '__%s_%s_h__' % (os.path.basename(path).lower(), tm)
    write_file(path + ".h", merge([
        header,
        '#ifndef %s' % head_def,
        '#define %s' % head_def,
        '',
        details,
        '#endif // %s' % head_def
        ]))

def get_header():
    return merge([
        '////////////////////////////////////////////////////////////////////////////////',
        '// NOTE : Generated by rawbuf. It is NOT supposed to modify this file.',
        '////////////////////////////////////////////////////////////////////////////////'
        ])

def get_member_methods():
    __construct_scalar = lambda member, scalar_dict: FILTER if not member[CTYPE] in scalar_dict else '    %s = %s;' % (
        member[NAME], scalar_dict[member[CTYPE]])
    __construct = {
        'dec': lambda declare, ctype: ('    %s();' % ctype) if declare else (
            '%s::%s()' % (ctype, ctype)
            ),
        'imp': lambda ctype, scalar_dict, members: merge([merge([
            '' if 0 != members.index(member) else FILTER,
            __construct_scalar(member, scalar_dict),
            '    __id_%s = %s;' % (member[NAME], member[ID]),
			'    __skip_%s = false;' % member[NAME],
            '    __rb_has_%s = false;' % member[NAME],
            ]) for member in members])
        }
    __assign = {
        'dec': lambda declare, ctype: ('    %s& operator=(const %s& obj_val);' % (ctype, ctype)) if declare else (
            '%s& %s::operator=(const %s& obj_val)' % (ctype, ctype, ctype)
            ),
        'imp': lambda ctype, scalar_dict, members: merge([
            merge(['    this->%s = obj_val.%s;' % (member[NAME], member[NAME]) for member in members]),
            '    return *this;'
            ])
        }
    __eq = {
        'dec': lambda declare, ctype: '    bool operator==(const %s& obj_val) const;' % ctype if declare else (
            'bool %s::operator==(const %s& obj_val) const' % (ctype, ctype)
            ),
        'imp': lambda ctype, scalar_dict, members: merge([
            merge(['    if (!(this->%s == obj_val.%s)) return false;' % (member[NAME], member[NAME]) for member in members]),
            '    return true;'
            ])
        }
    __rb_fields = {
        'dec': lambda declare, ctype: '    rb_field_size_t rb_fields() const;' if declare else (
            'rb_field_size_t %s::rb_fields() const' % ctype
            ),
        'imp': lambda ctype, scalar_dict, members: merge([
            '    rb_field_size_t fields = 0;',
            merge(['    if (!__skip_%s) ++fields;' % member[NAME] for member in members]),
            '    return fields;'
            ])
        }
    __rb_size = {
        'dec': lambda declare, ctype: '    rb_size_t rb_size() const;' if declare else (
            'rb_size_t %s::rb_size() const' % ctype
            ),
        'imp': lambda ctype, scalar_dict, members: merge([
            '    rb_field_size_t fields = 0;',
            '    rb_size_t size = 0;',
            merge([merge([
                '    if (!__skip_%s)' % member[NAME],
                '    {',
                '        size += rb_sizeof(%s);' % member[NAME],
                '        ++fields;',
                '    }',
                ]) for member in members]),
            '    size += rb_seek_field_table_item(fields);',
            '    size += sizeof(rb_buf_end_t);',
            '    return size;'
            ])
        }
    __encode = {
        'dec': lambda declare, ctype: '    bool encode(rb_buf_t& buf) const;' if declare else (
            'bool %s::encode(rb_buf_t& buf) const' % ctype
            ),
        'imp': lambda ctype, scalar_dict, members: merge([
            '    rb_field_size_t index = 0;',
            merge(['    if (!__skip_%s && !rb_encode_field(index++, __id_%s, %s, buf)) return false;' % (
                member[NAME], member[NAME], member[NAME]) for member in members]),
            '    return true;'
            ])
        }
    __decode = {
        'dec': lambda declare, ctype: '    bool decode(const rb_field_table_item_t& item, const rb_buf_t& buf);' if declare else (
            'bool %s::decode(const rb_field_table_item_t& item, const rb_buf_t& buf)' % ctype
            ),
        'imp': lambda ctype, scalar_dict, members: merge([
            '    bool rc = true;',
            '    do',
            '    {',
            merge(['        if (rb_decode_field(__id_%s, item, buf, rc, __rb_has_%s, %s)) break;' % (
                member[NAME], member[NAME], member[NAME]) for member in members]),
            '    } while (0);',
            '    return rc;'
            ])
        }
    return [__construct, __assign, __eq, __rb_fields, __rb_size, __encode, __decode]

def get_object_methods():
    __sizeof = {
        'dec': lambda ctype: 'rb_size_t rb_sizeof(const %s& obj_val)' % ctype,
        'imp': lambda ctype: '    return obj_val.rb_size();'
        }
    __encode = {
        'dec': lambda ctype: 'bool rb_encode(const %s& obj_val, rb_buf_t& rb_val)' % ctype,
        'imp': lambda ctype: '    return rb_encode_base(obj_val, rb_val);'
        }
    __decode = {
        'dec': lambda ctype: 'bool rb_decode(const rb_buf_t& rb_val, rb_offset_t offset, %s& obj_val)' % ctype,
        'imp': lambda ctype: '    return rb_decode_base(rb_val, offset, obj_val);'
        }
    __dump = {
        'dec': lambda ctype: 'bool rb_dump(const %s& obj_val, const char * path)' % ctype,
        'imp': lambda ctype: '    return rb_dump_base(obj_val, path);'
        }
    __load = {
        'dec': lambda ctype: 'bool rb_load(const char * path, %s& obj_val)' % ctype,
        'imp': lambda ctype: '    return rb_load_base(path, obj_val);'
        }
    return [__sizeof, __encode, __decode, __dump, __load]

def gen_from_schema(path, obj, scalar_dict, member_methods, object_methods):
    def __check(structs):
        for struct in structs:
            ctype = struct['type']
            if not ctype.endswith('_t'):
                print '"%s" is not end with "_t"' % ctype
                return False
            ids = set()
            for member in struct['members']:
                if len(member) > (ID + 1) or len(member) < (ID):
                    print 'invalid members: "%s" in struct "%s"' % (str(member), ctype)
                    return False
                if len(member) < (ID + 1):
                    continue
                id = member[ID]
                if int(id) > 255:
                    print 'invalid id (should be: [0, 255]): "%s" in struct "%s"' % (str(member), ctype)
                    return False
                if id in ids:
                    print '"%s" duplicated in "%s"' % (str(id), ctype)
                    return False
                else:
                    ids.add(id)
        return True
    def __get_ctype(key):
        is_array = lambda key: key.startswith('[') and key.endswith(']')
        is_dict = lambda key: key.startswith('{') and key.endswith('}')
        base_type = lambda key: key[1:len(key) - 1]
        if is_array(key):
            return 'std::vector<%s >' % __get_ctype(base_type(key))
        if is_dict(key):
            return 'std::map<std::string, %s >' % __get_ctype(base_type(key))
        if 'string' == key:
            return 'std::string'
        return key
    def __update_object(obj):
        def __update_ids(members):
            ids = [member[ID] for member in filter(lambda member: len(member) > ID, members)]
            default_ids = [str(members.index(member)) for member in members]
            for id in default_ids:
                if id in ids:
                    default_ids.remove(id)
            for member in members:
                if not len(member) > ID:
                    id = default_ids[0]
                    member.append(id)
                    default_ids.remove(id)
        for struct in obj['structs']:
            __update_ids(struct['members'])
            for member in struct['members']:
                member[CTYPE] = __get_ctype(member[CTYPE])
    def __gen_interface(path, obj, member_methods, object_methods):
        def __gen_struct(struct, member_methods, object_methods):
            __gen_def = lambda ctype, members: merge([
                'struct %s' % ctype,
                '{',
                merge(['    %s %s;' % (member[CTYPE], member[NAME]) for member in members]),
                '',
                merge(['    void skip_%s() { __skip_%s = true; }' % (member[NAME], member[NAME]) for member in members]),
                '',
                merge(['    bool rb_has_%s() const { return __rb_has_%s; }' % (member[NAME], member[NAME]) for member in members]),
                '',
                merge([method['dec'](True, ctype) for method in member_methods]),
                '',
                'private:',
                merge(['    rb_field_id_t __id_%s;' % member[NAME] for member in members]),
                '',
				merge(['    bool __skip_%s;' % member[NAME] for member in members]),
				'',
                merge(['    bool __rb_has_%s;' % member[NAME] for member in members]),
                '};',
                ''
                ])
            return merge([
                __gen_def(struct['type'], struct['members']),
                merge([method['dec'](struct['type']) + ';' for method in object_methods]),
                ''
                ])
        write_interface(path, get_header(), merge([
            '#include "rawbuf.h"',
            '',
            'namespace rawbuf {',
            '',
            merge([__gen_struct(struct, member_methods, object_methods) for struct in obj['structs']]),
            '} // namespace rawbuf',
            ''
            ]))
    def __gen_implement(path, obj, scalar_dict, member_methods, object_methods):
        def __gen_struct(struct, scalar_dict, member_methods, object_methods):
            __gen_member_imp = lambda ctype, members, method: merge([
                method['dec'](False, ctype),
                '{',
                method['imp'](ctype, scalar_dict, members),
                '}',
                ''
                ])
            __gen_imp = lambda ctype, members, method: merge([
                method['dec'](ctype),
                '{',
                method['imp'](ctype),
                '}',
                ''
                ])
            __gen_object_implement = lambda ctype, members, member_methods, object_methods: merge([
                merge([__gen_member_imp(ctype, members, method) for method in member_methods]),
                merge([__gen_imp(ctype, members, method) for method in object_methods])
                ])
            return merge([
                __gen_object_implement(struct['type'], struct['members'], member_methods, object_methods)
                ])
        write_file(path + ".cpp", merge([
            get_header(),
            '#include "%s.h"' % os.path.basename(path),
            '',
            'namespace rawbuf {',
            '',
            merge([__gen_struct(struct, scalar_dict, member_methods, object_methods) for struct in obj['structs']]),
            '} // namespace rawbuf'
            ]))
    if not __check(obj['structs']):
        return False
    __update_object(obj)
    __gen_interface(path, obj, member_methods, object_methods)
    __gen_implement(path, obj, scalar_dict, member_methods, object_methods)
    return True

def gen(file_list, scalar_dict, member_methods, object_methods):
    for path_item in file_list:
        with open(path_item, 'r') as f:
            obj = json.load(f)
            gen_from_schema(
                path_item[:path_item.rfind('.')], 
                obj, 
                scalar_dict,
                member_methods,
                object_methods)
    return True

def parse_shell(argv):
    size = len(argv)
    if 1 == size or 2 == size:
        return False
    op = argv[1]
    file_list = get_files(json_filter, op, argv[2:])
    return gen(
        file_list, 
        get_scalar_dict(), 
        get_member_methods(),
        get_object_methods()
        ) if len(file_list) > 0 else False

if __name__ == "__main__":
    if not parse_shell(sys.argv):
        manual()