////////////////////////////////////////////////////////////////////////////////
// NOTE : Generated by rawbuf. It is NOT supposed to modify this file.
////////////////////////////////////////////////////////////////////////////////
#include "sample_test.h"

namespace rawbuf {

sample_struct_t::sample_struct_t()
{
    int8_val = 0;
    __id_int8_val = 0;
    __skip_int8_val = false;
    __rb_has_int8_val = false;

    uint8_val = 0;
    __id_uint8_val = 1;
    __skip_uint8_val = false;
    __rb_has_uint8_val = false;

    __id_str_val = 100;
    __skip_str_val = false;
    __rb_has_str_val = false;

    __id_str_arr_val = 2;
    __skip_str_arr_val = false;
    __rb_has_str_arr_val = false;

    __id_str_dict_val = 3;
    __skip_str_dict_val = false;
    __rb_has_str_dict_val = false;
}

sample_struct_t& sample_struct_t::operator=(const sample_struct_t& obj_val)
{
    this->int8_val = obj_val.int8_val;
    this->uint8_val = obj_val.uint8_val;
    this->str_val = obj_val.str_val;
    this->str_arr_val = obj_val.str_arr_val;
    this->str_dict_val = obj_val.str_dict_val;
    return *this;
}

bool sample_struct_t::operator==(const sample_struct_t& obj_val) const
{
    if (!(this->int8_val == obj_val.int8_val)) return false;
    if (!(this->uint8_val == obj_val.uint8_val)) return false;
    if (!(this->str_val == obj_val.str_val)) return false;
    if (!(this->str_arr_val == obj_val.str_arr_val)) return false;
    if (!(this->str_dict_val == obj_val.str_dict_val)) return false;
    return true;
}

rb_field_size_t sample_struct_t::rb_fields() const
{
    rb_field_size_t fields = 0;
    if (!__skip_int8_val) ++fields;
    if (!__skip_uint8_val) ++fields;
    if (!__skip_str_val) ++fields;
    if (!__skip_str_arr_val) ++fields;
    if (!__skip_str_dict_val) ++fields;
    return fields;
}

rb_size_t sample_struct_t::rb_size() const
{
    rb_field_size_t fields = 0;
    rb_size_t size = 0;
    if (!__skip_int8_val)
    {
        size += rb_sizeof(int8_val);
        ++fields;
    }
    if (!__skip_uint8_val)
    {
        size += rb_sizeof(uint8_val);
        ++fields;
    }
    if (!__skip_str_val)
    {
        size += rb_sizeof(str_val);
        ++fields;
    }
    if (!__skip_str_arr_val)
    {
        size += rb_sizeof(str_arr_val);
        ++fields;
    }
    if (!__skip_str_dict_val)
    {
        size += rb_sizeof(str_dict_val);
        ++fields;
    }
    size += rb_seek_field_table_item(fields);
    size += sizeof(rb_buf_end_t);
    return size;
}

bool sample_struct_t::encode(rb_buf_t& buf) const
{
    rb_field_size_t index = 0;
    if (!__skip_int8_val && !rb_encode_field(index++, __id_int8_val, int8_val, buf)) return false;
    if (!__skip_uint8_val && !rb_encode_field(index++, __id_uint8_val, uint8_val, buf)) return false;
    if (!__skip_str_val && !rb_encode_field(index++, __id_str_val, str_val, buf)) return false;
    if (!__skip_str_arr_val && !rb_encode_field(index++, __id_str_arr_val, str_arr_val, buf)) return false;
    if (!__skip_str_dict_val && !rb_encode_field(index++, __id_str_dict_val, str_dict_val, buf)) return false;
    return true;
}

bool sample_struct_t::decode(const rb_field_table_item_t& item, const rb_buf_t& buf)
{
    bool rc = true;
    do
    {
        if (rb_decode_field(__id_int8_val, item, buf, rc, __rb_has_int8_val, int8_val)) break;
        if (rb_decode_field(__id_uint8_val, item, buf, rc, __rb_has_uint8_val, uint8_val)) break;
        if (rb_decode_field(__id_str_val, item, buf, rc, __rb_has_str_val, str_val)) break;
        if (rb_decode_field(__id_str_arr_val, item, buf, rc, __rb_has_str_arr_val, str_arr_val)) break;
        if (rb_decode_field(__id_str_dict_val, item, buf, rc, __rb_has_str_dict_val, str_dict_val)) break;
    } while (0);
    return rc;
}

rb_size_t rb_sizeof(const sample_struct_t& obj_val)
{
    return obj_val.rb_size();
}

bool rb_encode(const sample_struct_t& obj_val, rb_buf_t& rb_val)
{
    return rb_encode_base(obj_val, rb_val);
}

bool rb_decode(const rb_buf_t& rb_val, rb_offset_t offset, sample_struct_t& obj_val)
{
    return rb_decode_base(rb_val, offset, obj_val);
}

bool rb_dump(const sample_struct_t& obj_val, const char * path)
{
    return rb_dump_base(obj_val, path);
}

bool rb_load(const char * path, sample_struct_t& obj_val)
{
    return rb_load_base(path, obj_val);
}

sample_object_t::sample_object_t()
{
    __id_obj = 0;
    __skip_obj = false;
    __rb_has_obj = false;

    __id_arr = 1;
    __skip_arr = false;
    __rb_has_arr = false;

    __id_dict = 2;
    __skip_dict = false;
    __rb_has_dict = false;
}

sample_object_t& sample_object_t::operator=(const sample_object_t& obj_val)
{
    this->obj = obj_val.obj;
    this->arr = obj_val.arr;
    this->dict = obj_val.dict;
    return *this;
}

bool sample_object_t::operator==(const sample_object_t& obj_val) const
{
    if (!(this->obj == obj_val.obj)) return false;
    if (!(this->arr == obj_val.arr)) return false;
    if (!(this->dict == obj_val.dict)) return false;
    return true;
}

rb_field_size_t sample_object_t::rb_fields() const
{
    rb_field_size_t fields = 0;
    if (!__skip_obj) ++fields;
    if (!__skip_arr) ++fields;
    if (!__skip_dict) ++fields;
    return fields;
}

rb_size_t sample_object_t::rb_size() const
{
    rb_field_size_t fields = 0;
    rb_size_t size = 0;
    if (!__skip_obj)
    {
        size += rb_sizeof(obj);
        ++fields;
    }
    if (!__skip_arr)
    {
        size += rb_sizeof(arr);
        ++fields;
    }
    if (!__skip_dict)
    {
        size += rb_sizeof(dict);
        ++fields;
    }
    size += rb_seek_field_table_item(fields);
    size += sizeof(rb_buf_end_t);
    return size;
}

bool sample_object_t::encode(rb_buf_t& buf) const
{
    rb_field_size_t index = 0;
    if (!__skip_obj && !rb_encode_field(index++, __id_obj, obj, buf)) return false;
    if (!__skip_arr && !rb_encode_field(index++, __id_arr, arr, buf)) return false;
    if (!__skip_dict && !rb_encode_field(index++, __id_dict, dict, buf)) return false;
    return true;
}

bool sample_object_t::decode(const rb_field_table_item_t& item, const rb_buf_t& buf)
{
    bool rc = true;
    do
    {
        if (rb_decode_field(__id_obj, item, buf, rc, __rb_has_obj, obj)) break;
        if (rb_decode_field(__id_arr, item, buf, rc, __rb_has_arr, arr)) break;
        if (rb_decode_field(__id_dict, item, buf, rc, __rb_has_dict, dict)) break;
    } while (0);
    return rc;
}

rb_size_t rb_sizeof(const sample_object_t& obj_val)
{
    return obj_val.rb_size();
}

bool rb_encode(const sample_object_t& obj_val, rb_buf_t& rb_val)
{
    return rb_encode_base(obj_val, rb_val);
}

bool rb_decode(const rb_buf_t& rb_val, rb_offset_t offset, sample_object_t& obj_val)
{
    return rb_decode_base(rb_val, offset, obj_val);
}

bool rb_dump(const sample_object_t& obj_val, const char * path)
{
    return rb_dump_base(obj_val, path);
}

bool rb_load(const char * path, sample_object_t& obj_val)
{
    return rb_load_base(path, obj_val);
}

} // namespace rawbuf