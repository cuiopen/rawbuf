////////////////////////////////////////////////////////////////////////////////
// NOTE : Generated by rawbuf. It is NOT supposed to modify this file.
////////////////////////////////////////////////////////////////////////////////
#ifndef __sample_test_20160818103822_h__
#define __sample_test_20160818103822_h__

#include "rawbuf.h"

namespace rawbuf {

struct sample_struct_t
{
    int8_t int8_val;
    uint8_t uint8_val;
    std::string str_val;
    std::vector<std::string > str_arr_val;
    std::map<std::string, std::string > str_dict_val;

    void skip_int8_val() { __skip_int8_val = true; }
    void skip_uint8_val() { __skip_uint8_val = true; }
    void skip_str_val() { __skip_str_val = true; }
    void skip_str_arr_val() { __skip_str_arr_val = true; }
    void skip_str_dict_val() { __skip_str_dict_val = true; }

    bool rb_has_int8_val() const { return __rb_has_int8_val; }
    bool rb_has_uint8_val() const { return __rb_has_uint8_val; }
    bool rb_has_str_val() const { return __rb_has_str_val; }
    bool rb_has_str_arr_val() const { return __rb_has_str_arr_val; }
    bool rb_has_str_dict_val() const { return __rb_has_str_dict_val; }

    sample_struct_t();
    sample_struct_t& operator=(const sample_struct_t& obj_val);
    bool operator==(const sample_struct_t& obj_val) const;
    rb_field_size_t rb_fields() const;
    rb_size_t rb_size() const;
    bool encode(rb_buf_t& buf) const;
    bool decode(const rb_field_table_item_t& item, const rb_buf_t& buf);

private:
    rb_field_id_t __id_int8_val;
    rb_field_id_t __id_uint8_val;
    rb_field_id_t __id_str_val;
    rb_field_id_t __id_str_arr_val;
    rb_field_id_t __id_str_dict_val;

    bool __skip_int8_val;
    bool __skip_uint8_val;
    bool __skip_str_val;
    bool __skip_str_arr_val;
    bool __skip_str_dict_val;

    bool __rb_has_int8_val;
    bool __rb_has_uint8_val;
    bool __rb_has_str_val;
    bool __rb_has_str_arr_val;
    bool __rb_has_str_dict_val;
};

rb_size_t rb_sizeof(const sample_struct_t& obj_val);
bool rb_encode(const sample_struct_t& obj_val, rb_buf_t& rb_val);
bool rb_decode(const rb_buf_t& rb_val, rb_offset_t offset, sample_struct_t& obj_val);
bool rb_dump(const sample_struct_t& obj_val, const char * path);
bool rb_load(const char * path, sample_struct_t& obj_val);

struct sample_object_t
{
    sample_struct_t obj;
    std::vector<sample_struct_t > arr;
    std::map<std::string, sample_struct_t > dict;

    void skip_obj() { __skip_obj = true; }
    void skip_arr() { __skip_arr = true; }
    void skip_dict() { __skip_dict = true; }

    bool rb_has_obj() const { return __rb_has_obj; }
    bool rb_has_arr() const { return __rb_has_arr; }
    bool rb_has_dict() const { return __rb_has_dict; }

    sample_object_t();
    sample_object_t& operator=(const sample_object_t& obj_val);
    bool operator==(const sample_object_t& obj_val) const;
    rb_field_size_t rb_fields() const;
    rb_size_t rb_size() const;
    bool encode(rb_buf_t& buf) const;
    bool decode(const rb_field_table_item_t& item, const rb_buf_t& buf);

private:
    rb_field_id_t __id_obj;
    rb_field_id_t __id_arr;
    rb_field_id_t __id_dict;

    bool __skip_obj;
    bool __skip_arr;
    bool __skip_dict;

    bool __rb_has_obj;
    bool __rb_has_arr;
    bool __rb_has_dict;
};

rb_size_t rb_sizeof(const sample_object_t& obj_val);
bool rb_encode(const sample_object_t& obj_val, rb_buf_t& rb_val);
bool rb_decode(const rb_buf_t& rb_val, rb_offset_t offset, sample_object_t& obj_val);
bool rb_dump(const sample_object_t& obj_val, const char * path);
bool rb_load(const char * path, sample_object_t& obj_val);

} // namespace rawbuf

#endif // __sample_test_20160818103822_h__