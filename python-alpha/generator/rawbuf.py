#!/usr/bin/python
#author: jobs
#email: yao050421103@gmail.com
import sys
import os.path
import datetime
import string
import json

CTYPE = 0
NAME = 1
ID = 2
CREATOR = 3

FILTER = '@null_string_place_holder'
merge = lambda l: string.join(filter(lambda item: FILTER != item, l), '\n')
json_filter = lambda f: (lambda f, l: os.path.splitext(f)[1] in l)(f, ['.json'])

def manual(): 
    print """
    usage:
        python rawbuf.py [option] filelist
            [option]
                -f: use file in filelist
                -p: use dir in filelist, will be parsed recursive
                
    sample:
        python rawbuf.py -f file1.json file2.json file3.json
        python rawbuf.py -p ./dir1/ ./dir2/ ./dir3/
        """

def get_file_list(cur_dir, path_filter):
    def __get(cur_dir, path_filter, file_list):
        for root, dirs, files in os.walk(cur_dir): 
            for f in files:
                if path_filter(f):
                    file_list.append(os.path.join(root, f))
    file_list = []
    __get(cur_dir, path_filter, file_list)
    return file_list

def get_files(file_filter, op, urls):
    if '-f' == op:
        return filter(file_filter, urls)
    elif '-p' == op:
        file_set = set()
        for url in urls:
            for item in get_file_list(url, file_filter):
                if not item in file_set:
                    file_set.add(item)
        return list(file_set)
    return []

def write_file(url, data):
    with open(url, 'w') as f:
        f.writelines(data)

def get_scalar_dict():
    return {
        'bool': 'rb_bool_t',
        'int8_t': 'rb_int8_t',
        'uint8_t': 'rb_uint8_t',
        'short': 'rb_int16_t',
        'int16_t': 'rb_int16_t',
        'uint16_t': 'rb_uint16_t',
        'int': 'rb_int32_t',
        'int32_t': 'rb_int32_t',
        'uint32_t': 'rb_uint32_t',
        'long': 'rb_int64_t',
        'int64_t': 'rb_int64_t',
        'uint64_t': 'rb_uint64_t',
        'float': 'rb_float_t',
        'double': 'rb_double_t'
        }

def get_header():
    return merge([
        '#!/usr/bin/python',
        '#===============================================================================',
        '# NOTE : Generated by rawbuf. It is NOT supposed to modify this file.',
        '#==============================================================================='
        ])

def get_member_methods():
    __eq = lambda ctype, members, method: merge([
        '    def __eq__(self, other):',
        merge([merge([
            '        if not self.%s == other.%s:' % (member[NAME], member[NAME]),
            '            return False'
            ]) for member in members]),
        '        return True'
        ])
    __reset = lambda ctype, members, method: merge([
        '    def reset(self):',
        merge(['        self.%s.reset()' % member[NAME] for member in members])
        ])
    __assign = lambda ctype, members, method: merge([
        '    def assign(self, other):',
        merge(['        self.%s.assign(other.%s)' % (member[NAME], member[NAME]) for member in members])
        ])
    __encode = lambda ctype, members, method: merge([
        '    def encode(self, buf):',
        '        index = 0',
        merge([merge([
            '        if not self.__skip_%s:' % member[NAME],
            '            if not rb_encode_field(index, self.__id_%s, self.%s, buf):' % (member[NAME], member[NAME]),
            '                return False',
            '            index = index + 1'
            ]) for member in members]),
        '        return True'
        ])
    __decode = lambda ctype, members, method: merge([
        '    def decode(self, id, offset, buf):',
        '        rc = rb_bool_t(True)',
        merge([merge([
            '        if rb_decode_field(self.__id_%s, id, offset, buf, rc, self.__rb_has_%s, self.%s):' % (
                member[NAME], member[NAME], member[NAME]),
            '            return rc.val'
            ]) for member in members]),
        '        return rc.val'
        ])
    __rb_fields = lambda ctype, members, method: merge([
        '    def rb_fields(self):',
        '        fields = 0',
        merge(['        if not self.__skip_%s: fields = fields + 1' % member[NAME] for member in members]),
        '        return fields'
        ])
    __rb_size = lambda ctype, members, method: merge([
        '    def rb_size(self):',
        '        fields = 0',
        '        size = 0',
        merge([merge([
            '        if not self.__skip_%s:' % member[NAME],
            '            size += self.%s.rb_size()' % member[NAME],
            '            fields = fields + 1'
            ]) for member in members]),
        '        size += rb_seek_field_table_item(fields)',
        '        size += rb_buf_end_t.rb_size()',
        '        return size'
        ])
    return [__eq, __reset, __assign, __encode, __decode, __rb_fields, __rb_size]

def gen_from_schema(path, obj, scalar_dict, member_methods):
    def __check(structs):
        for struct in structs:
            ctype = struct['type']
            if not ctype.endswith('_t'):
                print '"%s" is not end with "_t"' % ctype
                return False
            ids = set()
            for member in struct['members']:
                if len(member) > (ID + 1) or len(member) < (ID):
                    print 'invalid members: "%s" in struct "%s"' % (str(member), ctype)
                    return False
                if len(member) < (ID + 1):
                    continue
                id = member[ID]
                if int(id) > 255:
                    print 'invalid id (should be: [0, 255]): "%s" in struct "%s"' % (str(member), ctype)
                    return False
                if id in ids:
                    print '"%s" duplicated in "%s"' % (str(id), ctype)
                    return False
                else:
                    ids.add(id)
        return True
    def __get_creator(nested, key, scalar_dict):
        def __get_base_creator(nested, key, scalar_dict):
            format_str = lambda nested: '[%s, None]' if nested else '%s()'
            if 'rb_list_t' == key or 'rb_dict_t' == key:
                raise TypeError("invalid key")
            if key in scalar_dict:
                return format_str(nested) % scalar_dict[key]
            return format_str(nested) % key
        is_array = lambda key: key.startswith('[') and key.endswith(']')
        is_dict = lambda key: key.startswith('{') and key.endswith('}')
        base_type = lambda key: key[1:len(key) - 1]
        if is_array(key):
            return 'rb_list_t(%s)' % __get_creator(True, base_type(key), scalar_dict)
        if is_dict(key):
            return 'rb_dict_t(%s)' % __get_creator(True, base_type(key), scalar_dict)
        if 'string' == key:
            return '[rb_string_t, None]' if nested else 'rb_string_t()'
        return __get_base_creator(nested, key, scalar_dict)
    def __update_object(obj, scalar_dict):
        def __update_ids(members):
            ids = [member[ID] for member in filter(lambda member: len(member) > ID, members)]
            default_ids = [str(members.index(member)) for member in members]
            for id in default_ids:
                if id in ids:
                    default_ids.remove(id)
            for member in members:
                if not len(member) > ID:
                    id = default_ids[0]
                    member.append(id)
                    default_ids.remove(id)
        for struct in obj['structs']:
            __update_ids(struct['members'])
            for member in struct['members']:
                member.append(__get_creator(False, member[CTYPE], scalar_dict))
    def __gen_implement(path, obj, scalar_dict, member_methods):
        def __gen_struct(struct, scalar_dict, member_methods):
            __gen_def = lambda ctype, members: merge([
                'class %s:' % ctype,
                '    def __init__(self):',
                '        # fields',
                merge(['        self.%s = %s' % (member[NAME], member[CREATOR]) for member in members]),
                '        # ids',
                merge(['        self.__id_%s = %s' % (member[NAME], member[ID]) for member in members]),
                '        # flags',
                merge(['        self.__skip_%s = False' % member[NAME] for member in members]),
                merge(['        self.__rb_has_%s = rb_bool_t()' % member[NAME] for member in members]),
                merge([merge([
                    '    def skip_%s(self):' % member[NAME],
                    '        self.__skip_%s = True' % member[NAME]
                    ]) for member in members]),
                merge([merge([
                    '    def rb_has_%s(self):' % member[NAME],
                    '        return self.__rb_has_%s.val' % member[NAME]
                    ]) for member in members])
                ])
            __gen_wrap_methods = merge([
                '    def rb_encode(self, rb_val):',
                '        return rb_encode_base(self, rb_val)',
                '    def rb_decode(self, rb_val, offset):',
                '        return rb_decode_base(rb_val, offset, self)',
                '    def rb_dump(self, path):',
                '        return rb_dump_base(self, path)',
                '    def rb_load(self, path):',
                '        return rb_load_base(path, self)',
                ''
                ])
            return merge([
                __gen_def(struct['type'], struct['members']),
                merge([method(struct['type'], struct['members'], method) for method in member_methods]),
                __gen_wrap_methods
                ])
        write_file(path + ".py", merge([
            get_header(),
            'from rawbuf import *',
            '',
            merge([__gen_struct(struct, scalar_dict, member_methods) for struct in obj['structs']]),
            'if __name__ == "__main__":',
            '    pass'
            ]))
    if not __check(obj['structs']):
        return False
    __update_object(obj, scalar_dict)
    __gen_implement(path, obj, scalar_dict, member_methods)
    return True

def gen(file_list, scalar_dict, member_methods):
    for path_item in file_list:
        with open(path_item, 'r') as f:
            obj = json.load(f)
            gen_from_schema(
                path_item[:path_item.rfind('.')], 
                obj, 
                scalar_dict,
                member_methods)
    return True

def parse_shell(argv):
    size = len(argv)
    if 1 == size or 2 == size:
        return False
    op = argv[1]
    file_list = get_files(json_filter, op, argv[2:])
    return gen(
        file_list, 
        get_scalar_dict(), 
        get_member_methods()
        ) if len(file_list) > 0 else False

if __name__ == "__main__":
    if not parse_shell(sys.argv):
        manual()