#!/usr/bin/python
#===============================================================================
# NOTE : Generated by rawbuf. It is NOT supposed to modify this file.
#===============================================================================
from rawbuf_utils import *

def rb_sizeof_bool(obj_val):
    return sizeof_bool

def rb_sizeof_int8(obj_val):
    return sizeof_int8

def rb_sizeof_uint8(obj_val):
    return sizeof_uint8

def rb_sizeof_int16(obj_val):
    return sizeof_int16

def rb_sizeof_uint16(obj_val):
    return sizeof_uint16

def rb_sizeof_int32(obj_val):
    return sizeof_int32

def rb_sizeof_uint32(obj_val):
    return sizeof_uint32

def rb_sizeof_int64(obj_val):
    return sizeof_int64

def rb_sizeof_uint64(obj_val):
    return sizeof_uint64

def rb_sizeof_float(obj_val):
    return sizeof_float

def rb_sizeof_double(obj_val):
    return sizeof_double

def rb_encode_bool(obj_val, rb_val):
    size = sizeof_bool
    if not rb_encode_check(rb_val, size):
        return False
    to_memory(bool_fmt, rb_val["data"], rb_val["pos"], obj_val)
    rb_val["pos"] += size
    return True

def rb_encode_int8(obj_val, rb_val):
    size = sizeof_int8
    if not rb_encode_check(rb_val, size):
        return False
    to_memory(int8_fmt, rb_val["data"], rb_val["pos"], obj_val)
    rb_val["pos"] += size
    return True

def rb_encode_uint8(obj_val, rb_val):
    size = sizeof_uint8
    if not rb_encode_check(rb_val, size):
        return False
    to_memory(uint8_fmt, rb_val["data"], rb_val["pos"], obj_val)
    rb_val["pos"] += size
    return True

def rb_encode_int16(obj_val, rb_val):
    size = sizeof_int16
    if not rb_encode_check(rb_val, size):
        return False
    to_memory(int16_fmt, rb_val["data"], rb_val["pos"], obj_val)
    rb_val["pos"] += size
    return True

def rb_encode_uint16(obj_val, rb_val):
    size = sizeof_uint16
    if not rb_encode_check(rb_val, size):
        return False
    to_memory(uint16_fmt, rb_val["data"], rb_val["pos"], obj_val)
    rb_val["pos"] += size
    return True

def rb_encode_int32(obj_val, rb_val):
    size = sizeof_int32
    if not rb_encode_check(rb_val, size):
        return False
    to_memory(int32_fmt, rb_val["data"], rb_val["pos"], obj_val)
    rb_val["pos"] += size
    return True

def rb_encode_uint32(obj_val, rb_val):
    size = sizeof_uint32
    if not rb_encode_check(rb_val, size):
        return False
    to_memory(uint32_fmt, rb_val["data"], rb_val["pos"], obj_val)
    rb_val["pos"] += size
    return True

def rb_encode_int64(obj_val, rb_val):
    size = sizeof_int64
    if not rb_encode_check(rb_val, size):
        return False
    to_memory(int64_fmt, rb_val["data"], rb_val["pos"], obj_val)
    rb_val["pos"] += size
    return True

def rb_encode_uint64(obj_val, rb_val):
    size = sizeof_uint64
    if not rb_encode_check(rb_val, size):
        return False
    to_memory(uint64_fmt, rb_val["data"], rb_val["pos"], obj_val)
    rb_val["pos"] += size
    return True

def rb_encode_float(obj_val, rb_val):
    size = sizeof_float
    if not rb_encode_check(rb_val, size):
        return False
    to_memory(float_fmt, rb_val["data"], rb_val["pos"], obj_val)
    rb_val["pos"] += size
    return True

def rb_encode_double(obj_val, rb_val):
    size = sizeof_double
    if not rb_encode_check(rb_val, size):
        return False
    to_memory(double_fmt, rb_val["data"], rb_val["pos"], obj_val)
    rb_val["pos"] += size
    return True

def rb_decode_bool(rb_val, offset):
    size = sizeof_bool
    if not rb_decode_check(rb_val, offset, size):
        return (None, False)
    return (from_memory(bool_fmt, rb_val["data"], rb_val["start"] + offset), True)

def rb_decode_int8(rb_val, offset):
    size = sizeof_int8
    if not rb_decode_check(rb_val, offset, size):
        return (None, False)
    return (from_memory(int8_fmt, rb_val["data"], rb_val["start"] + offset), True)

def rb_decode_uint8(rb_val, offset):
    size = sizeof_uint8
    if not rb_decode_check(rb_val, offset, size):
        return (None, False)
    return (from_memory(uint8_fmt, rb_val["data"], rb_val["start"] + offset), True)

def rb_decode_int16(rb_val, offset):
    size = sizeof_int16
    if not rb_decode_check(rb_val, offset, size):
        return (None, False)
    return (from_memory(int16_fmt, rb_val["data"], rb_val["start"] + offset), True)

def rb_decode_uint16(rb_val, offset):
    size = sizeof_uint16
    if not rb_decode_check(rb_val, offset, size):
        return (None, False)
    return (from_memory(uint16_fmt, rb_val["data"], rb_val["start"] + offset), True)

def rb_decode_int32(rb_val, offset):
    size = sizeof_int32
    if not rb_decode_check(rb_val, offset, size):
        return (None, False)
    return (from_memory(int32_fmt, rb_val["data"], rb_val["start"] + offset), True)

def rb_decode_uint32(rb_val, offset):
    size = sizeof_uint32
    if not rb_decode_check(rb_val, offset, size):
        return (None, False)
    return (from_memory(uint32_fmt, rb_val["data"], rb_val["start"] + offset), True)

def rb_decode_int64(rb_val, offset):
    size = sizeof_int64
    if not rb_decode_check(rb_val, offset, size):
        return (None, False)
    return (from_memory(int64_fmt, rb_val["data"], rb_val["start"] + offset), True)

def rb_decode_uint64(rb_val, offset):
    size = sizeof_uint64
    if not rb_decode_check(rb_val, offset, size):
        return (None, False)
    return (from_memory(uint64_fmt, rb_val["data"], rb_val["start"] + offset), True)

def rb_decode_float(rb_val, offset):
    size = sizeof_float
    if not rb_decode_check(rb_val, offset, size):
        return (None, False)
    return (from_memory(float_fmt, rb_val["data"], rb_val["start"] + offset), True)

def rb_decode_double(rb_val, offset):
    size = sizeof_double
    if not rb_decode_check(rb_val, offset, size):
        return (None, False)
    return (from_memory(double_fmt, rb_val["data"], rb_val["start"] + offset), True)

def rb_eq_bool_array(src, dst):
    ssize = len(src)
    dsize = len(dst)
    if ssize != dsize:
        return False
    for i in xrange(ssize):
        if src[i] != dst[i]:
            return False
    return True

def rb_sizeof_bool_array(obj_val):
    size = sizeof_rb_size + len(obj_val) * sizeof_rb_size
    for item in obj_val:
        size += rb_sizeof_bool(item)
    return size

def rb_encode_bool_array(obj_val, rb_val):
    buf = rb_nested_buf(rb_val, 0)
    if buf["size"] < 1:
        return False
    count = len(obj_val)
    if not rb_set_array_count(count, buf):
        return False
    i = 0
    for item in obj_val:
        if not rb_set_array_table_item(i, buf["pos"] - buf["start"], buf):
            return False
        if not rb_encode_bool(item, buf):
            return False
        i = i + 1
    rb_val["pos"] = buf["pos"]
    return True

def rb_decode_bool_array(rb_val, offset):
    obj_val = []
    buf = rb_nested_buf(rb_val, offset)
    if buf["size"] < 1:
        return (None, False)
    size = rb_get_array_count(buf)
    if size < 1:
        return (obj_val, True)
    rc = True
    for i in xrange(size):
        (off, ok) = rb_get_array_table_item(i, buf)
        if not ok:
            rc = False
            break
        (val, ok) = rb_decode_bool(buf, off)
        if not ok:
            rc = False
            break
        obj_val.append(val)
    return (obj_val, rc)

def rb_eq_int8_array(src, dst):
    ssize = len(src)
    dsize = len(dst)
    if ssize != dsize:
        return False
    for i in xrange(ssize):
        if src[i] != dst[i]:
            return False
    return True

def rb_sizeof_int8_array(obj_val):
    size = sizeof_rb_size + len(obj_val) * sizeof_rb_size
    for item in obj_val:
        size += rb_sizeof_int8(item)
    return size

def rb_encode_int8_array(obj_val, rb_val):
    buf = rb_nested_buf(rb_val, 0)
    if buf["size"] < 1:
        return False
    count = len(obj_val)
    if not rb_set_array_count(count, buf):
        return False
    i = 0
    for item in obj_val:
        if not rb_set_array_table_item(i, buf["pos"] - buf["start"], buf):
            return False
        if not rb_encode_int8(item, buf):
            return False
        i = i + 1
    rb_val["pos"] = buf["pos"]
    return True

def rb_decode_int8_array(rb_val, offset):
    obj_val = []
    buf = rb_nested_buf(rb_val, offset)
    if buf["size"] < 1:
        return (None, False)
    size = rb_get_array_count(buf)
    if size < 1:
        return (obj_val, True)
    rc = True
    for i in xrange(size):
        (off, ok) = rb_get_array_table_item(i, buf)
        if not ok:
            rc = False
            break
        (val, ok) = rb_decode_int8(buf, off)
        if not ok:
            rc = False
            break
        obj_val.append(val)
    return (obj_val, rc)

def rb_eq_uint8_array(src, dst):
    ssize = len(src)
    dsize = len(dst)
    if ssize != dsize:
        return False
    for i in xrange(ssize):
        if src[i] != dst[i]:
            return False
    return True

def rb_sizeof_uint8_array(obj_val):
    size = sizeof_rb_size + len(obj_val) * sizeof_rb_size
    for item in obj_val:
        size += rb_sizeof_uint8(item)
    return size

def rb_encode_uint8_array(obj_val, rb_val):
    buf = rb_nested_buf(rb_val, 0)
    if buf["size"] < 1:
        return False
    count = len(obj_val)
    if not rb_set_array_count(count, buf):
        return False
    i = 0
    for item in obj_val:
        if not rb_set_array_table_item(i, buf["pos"] - buf["start"], buf):
            return False
        if not rb_encode_uint8(item, buf):
            return False
        i = i + 1
    rb_val["pos"] = buf["pos"]
    return True

def rb_decode_uint8_array(rb_val, offset):
    obj_val = []
    buf = rb_nested_buf(rb_val, offset)
    if buf["size"] < 1:
        return (None, False)
    size = rb_get_array_count(buf)
    if size < 1:
        return (obj_val, True)
    rc = True
    for i in xrange(size):
        (off, ok) = rb_get_array_table_item(i, buf)
        if not ok:
            rc = False
            break
        (val, ok) = rb_decode_uint8(buf, off)
        if not ok:
            rc = False
            break
        obj_val.append(val)
    return (obj_val, rc)

def rb_eq_int16_array(src, dst):
    ssize = len(src)
    dsize = len(dst)
    if ssize != dsize:
        return False
    for i in xrange(ssize):
        if src[i] != dst[i]:
            return False
    return True

def rb_sizeof_int16_array(obj_val):
    size = sizeof_rb_size + len(obj_val) * sizeof_rb_size
    for item in obj_val:
        size += rb_sizeof_int16(item)
    return size

def rb_encode_int16_array(obj_val, rb_val):
    buf = rb_nested_buf(rb_val, 0)
    if buf["size"] < 1:
        return False
    count = len(obj_val)
    if not rb_set_array_count(count, buf):
        return False
    i = 0
    for item in obj_val:
        if not rb_set_array_table_item(i, buf["pos"] - buf["start"], buf):
            return False
        if not rb_encode_int16(item, buf):
            return False
        i = i + 1
    rb_val["pos"] = buf["pos"]
    return True

def rb_decode_int16_array(rb_val, offset):
    obj_val = []
    buf = rb_nested_buf(rb_val, offset)
    if buf["size"] < 1:
        return (None, False)
    size = rb_get_array_count(buf)
    if size < 1:
        return (obj_val, True)
    rc = True
    for i in xrange(size):
        (off, ok) = rb_get_array_table_item(i, buf)
        if not ok:
            rc = False
            break
        (val, ok) = rb_decode_int16(buf, off)
        if not ok:
            rc = False
            break
        obj_val.append(val)
    return (obj_val, rc)

def rb_eq_uint16_array(src, dst):
    ssize = len(src)
    dsize = len(dst)
    if ssize != dsize:
        return False
    for i in xrange(ssize):
        if src[i] != dst[i]:
            return False
    return True

def rb_sizeof_uint16_array(obj_val):
    size = sizeof_rb_size + len(obj_val) * sizeof_rb_size
    for item in obj_val:
        size += rb_sizeof_uint16(item)
    return size

def rb_encode_uint16_array(obj_val, rb_val):
    buf = rb_nested_buf(rb_val, 0)
    if buf["size"] < 1:
        return False
    count = len(obj_val)
    if not rb_set_array_count(count, buf):
        return False
    i = 0
    for item in obj_val:
        if not rb_set_array_table_item(i, buf["pos"] - buf["start"], buf):
            return False
        if not rb_encode_uint16(item, buf):
            return False
        i = i + 1
    rb_val["pos"] = buf["pos"]
    return True

def rb_decode_uint16_array(rb_val, offset):
    obj_val = []
    buf = rb_nested_buf(rb_val, offset)
    if buf["size"] < 1:
        return (None, False)
    size = rb_get_array_count(buf)
    if size < 1:
        return (obj_val, True)
    rc = True
    for i in xrange(size):
        (off, ok) = rb_get_array_table_item(i, buf)
        if not ok:
            rc = False
            break
        (val, ok) = rb_decode_uint16(buf, off)
        if not ok:
            rc = False
            break
        obj_val.append(val)
    return (obj_val, rc)

def rb_eq_int32_array(src, dst):
    ssize = len(src)
    dsize = len(dst)
    if ssize != dsize:
        return False
    for i in xrange(ssize):
        if src[i] != dst[i]:
            return False
    return True

def rb_sizeof_int32_array(obj_val):
    size = sizeof_rb_size + len(obj_val) * sizeof_rb_size
    for item in obj_val:
        size += rb_sizeof_int32(item)
    return size

def rb_encode_int32_array(obj_val, rb_val):
    buf = rb_nested_buf(rb_val, 0)
    if buf["size"] < 1:
        return False
    count = len(obj_val)
    if not rb_set_array_count(count, buf):
        return False
    i = 0
    for item in obj_val:
        if not rb_set_array_table_item(i, buf["pos"] - buf["start"], buf):
            return False
        if not rb_encode_int32(item, buf):
            return False
        i = i + 1
    rb_val["pos"] = buf["pos"]
    return True

def rb_decode_int32_array(rb_val, offset):
    obj_val = []
    buf = rb_nested_buf(rb_val, offset)
    if buf["size"] < 1:
        return (None, False)
    size = rb_get_array_count(buf)
    if size < 1:
        return (obj_val, True)
    rc = True
    for i in xrange(size):
        (off, ok) = rb_get_array_table_item(i, buf)
        if not ok:
            rc = False
            break
        (val, ok) = rb_decode_int32(buf, off)
        if not ok:
            rc = False
            break
        obj_val.append(val)
    return (obj_val, rc)

def rb_eq_uint32_array(src, dst):
    ssize = len(src)
    dsize = len(dst)
    if ssize != dsize:
        return False
    for i in xrange(ssize):
        if src[i] != dst[i]:
            return False
    return True

def rb_sizeof_uint32_array(obj_val):
    size = sizeof_rb_size + len(obj_val) * sizeof_rb_size
    for item in obj_val:
        size += rb_sizeof_uint32(item)
    return size

def rb_encode_uint32_array(obj_val, rb_val):
    buf = rb_nested_buf(rb_val, 0)
    if buf["size"] < 1:
        return False
    count = len(obj_val)
    if not rb_set_array_count(count, buf):
        return False
    i = 0
    for item in obj_val:
        if not rb_set_array_table_item(i, buf["pos"] - buf["start"], buf):
            return False
        if not rb_encode_uint32(item, buf):
            return False
        i = i + 1
    rb_val["pos"] = buf["pos"]
    return True

def rb_decode_uint32_array(rb_val, offset):
    obj_val = []
    buf = rb_nested_buf(rb_val, offset)
    if buf["size"] < 1:
        return (None, False)
    size = rb_get_array_count(buf)
    if size < 1:
        return (obj_val, True)
    rc = True
    for i in xrange(size):
        (off, ok) = rb_get_array_table_item(i, buf)
        if not ok:
            rc = False
            break
        (val, ok) = rb_decode_uint32(buf, off)
        if not ok:
            rc = False
            break
        obj_val.append(val)
    return (obj_val, rc)

def rb_eq_int64_array(src, dst):
    ssize = len(src)
    dsize = len(dst)
    if ssize != dsize:
        return False
    for i in xrange(ssize):
        if src[i] != dst[i]:
            return False
    return True

def rb_sizeof_int64_array(obj_val):
    size = sizeof_rb_size + len(obj_val) * sizeof_rb_size
    for item in obj_val:
        size += rb_sizeof_int64(item)
    return size

def rb_encode_int64_array(obj_val, rb_val):
    buf = rb_nested_buf(rb_val, 0)
    if buf["size"] < 1:
        return False
    count = len(obj_val)
    if not rb_set_array_count(count, buf):
        return False
    i = 0
    for item in obj_val:
        if not rb_set_array_table_item(i, buf["pos"] - buf["start"], buf):
            return False
        if not rb_encode_int64(item, buf):
            return False
        i = i + 1
    rb_val["pos"] = buf["pos"]
    return True

def rb_decode_int64_array(rb_val, offset):
    obj_val = []
    buf = rb_nested_buf(rb_val, offset)
    if buf["size"] < 1:
        return (None, False)
    size = rb_get_array_count(buf)
    if size < 1:
        return (obj_val, True)
    rc = True
    for i in xrange(size):
        (off, ok) = rb_get_array_table_item(i, buf)
        if not ok:
            rc = False
            break
        (val, ok) = rb_decode_int64(buf, off)
        if not ok:
            rc = False
            break
        obj_val.append(val)
    return (obj_val, rc)

def rb_eq_uint64_array(src, dst):
    ssize = len(src)
    dsize = len(dst)
    if ssize != dsize:
        return False
    for i in xrange(ssize):
        if src[i] != dst[i]:
            return False
    return True

def rb_sizeof_uint64_array(obj_val):
    size = sizeof_rb_size + len(obj_val) * sizeof_rb_size
    for item in obj_val:
        size += rb_sizeof_uint64(item)
    return size

def rb_encode_uint64_array(obj_val, rb_val):
    buf = rb_nested_buf(rb_val, 0)
    if buf["size"] < 1:
        return False
    count = len(obj_val)
    if not rb_set_array_count(count, buf):
        return False
    i = 0
    for item in obj_val:
        if not rb_set_array_table_item(i, buf["pos"] - buf["start"], buf):
            return False
        if not rb_encode_uint64(item, buf):
            return False
        i = i + 1
    rb_val["pos"] = buf["pos"]
    return True

def rb_decode_uint64_array(rb_val, offset):
    obj_val = []
    buf = rb_nested_buf(rb_val, offset)
    if buf["size"] < 1:
        return (None, False)
    size = rb_get_array_count(buf)
    if size < 1:
        return (obj_val, True)
    rc = True
    for i in xrange(size):
        (off, ok) = rb_get_array_table_item(i, buf)
        if not ok:
            rc = False
            break
        (val, ok) = rb_decode_uint64(buf, off)
        if not ok:
            rc = False
            break
        obj_val.append(val)
    return (obj_val, rc)

def rb_eq_float_array(src, dst):
    ssize = len(src)
    dsize = len(dst)
    if ssize != dsize:
        return False
    for i in xrange(ssize):
        if src[i] != dst[i]:
            return False
    return True

def rb_sizeof_float_array(obj_val):
    size = sizeof_rb_size + len(obj_val) * sizeof_rb_size
    for item in obj_val:
        size += rb_sizeof_float(item)
    return size

def rb_encode_float_array(obj_val, rb_val):
    buf = rb_nested_buf(rb_val, 0)
    if buf["size"] < 1:
        return False
    count = len(obj_val)
    if not rb_set_array_count(count, buf):
        return False
    i = 0
    for item in obj_val:
        if not rb_set_array_table_item(i, buf["pos"] - buf["start"], buf):
            return False
        if not rb_encode_float(item, buf):
            return False
        i = i + 1
    rb_val["pos"] = buf["pos"]
    return True

def rb_decode_float_array(rb_val, offset):
    obj_val = []
    buf = rb_nested_buf(rb_val, offset)
    if buf["size"] < 1:
        return (None, False)
    size = rb_get_array_count(buf)
    if size < 1:
        return (obj_val, True)
    rc = True
    for i in xrange(size):
        (off, ok) = rb_get_array_table_item(i, buf)
        if not ok:
            rc = False
            break
        (val, ok) = rb_decode_float(buf, off)
        if not ok:
            rc = False
            break
        obj_val.append(val)
    return (obj_val, rc)

def rb_eq_double_array(src, dst):
    ssize = len(src)
    dsize = len(dst)
    if ssize != dsize:
        return False
    for i in xrange(ssize):
        if src[i] != dst[i]:
            return False
    return True

def rb_sizeof_double_array(obj_val):
    size = sizeof_rb_size + len(obj_val) * sizeof_rb_size
    for item in obj_val:
        size += rb_sizeof_double(item)
    return size

def rb_encode_double_array(obj_val, rb_val):
    buf = rb_nested_buf(rb_val, 0)
    if buf["size"] < 1:
        return False
    count = len(obj_val)
    if not rb_set_array_count(count, buf):
        return False
    i = 0
    for item in obj_val:
        if not rb_set_array_table_item(i, buf["pos"] - buf["start"], buf):
            return False
        if not rb_encode_double(item, buf):
            return False
        i = i + 1
    rb_val["pos"] = buf["pos"]
    return True

def rb_decode_double_array(rb_val, offset):
    obj_val = []
    buf = rb_nested_buf(rb_val, offset)
    if buf["size"] < 1:
        return (None, False)
    size = rb_get_array_count(buf)
    if size < 1:
        return (obj_val, True)
    rc = True
    for i in xrange(size):
        (off, ok) = rb_get_array_table_item(i, buf)
        if not ok:
            rc = False
            break
        (val, ok) = rb_decode_double(buf, off)
        if not ok:
            rc = False
            break
        obj_val.append(val)
    return (obj_val, rc)

def rb_eq_string_array(src, dst):
    ssize = len(src)
    dsize = len(dst)
    if ssize != dsize:
        return False
    for i in xrange(ssize):
        if src[i] != dst[i]:
            return False
    return True

def rb_sizeof_string_array(obj_val):
    size = sizeof_rb_size + len(obj_val) * sizeof_rb_size
    for item in obj_val:
        size += rb_sizeof_string(item)
    return size

def rb_encode_string_array(obj_val, rb_val):
    buf = rb_nested_buf(rb_val, 0)
    if buf["size"] < 1:
        return False
    count = len(obj_val)
    if not rb_set_array_count(count, buf):
        return False
    i = 0
    for item in obj_val:
        if not rb_set_array_table_item(i, buf["pos"] - buf["start"], buf):
            return False
        if not rb_encode_string(item, buf):
            return False
        i = i + 1
    rb_val["pos"] = buf["pos"]
    return True

def rb_decode_string_array(rb_val, offset):
    obj_val = []
    buf = rb_nested_buf(rb_val, offset)
    if buf["size"] < 1:
        return (None, False)
    size = rb_get_array_count(buf)
    if size < 1:
        return (obj_val, True)
    rc = True
    for i in xrange(size):
        (off, ok) = rb_get_array_table_item(i, buf)
        if not ok:
            rc = False
            break
        (val, ok) = rb_decode_string(buf, off)
        if not ok:
            rc = False
            break
        obj_val.append(val)
    return (obj_val, rc)

def rb_eq_bool_dict(src, dst):
    ssize = len(src)
    dsize = len(dst)
    if ssize != dsize:
        return False
    for key in src:
        if not key in dst:
            return False
        if src[key] != dst[key]:
            return False
    return True

def rb_sizeof_bool_dict(obj_val):
    size = sizeof_rb_size + len(obj_val) * sizeof_rb_size
    for key in obj_val:
        size += rb_sizeof_string(key)
        size += rb_sizeof_bool(obj_val[key])
    return size

def rb_encode_bool_dict(obj_val, rb_val):
    buf = rb_nested_buf(rb_val, 0)
    if buf["size"] < 1:
        return False
    count = len(obj_val)
    if not rb_set_array_count(count, buf):
        return False
    i = 0
    for key in obj_val:
        if not rb_set_array_table_item(i, buf["pos"] - buf["start"], buf):
            return False
        if not rb_encode_string(key, buf):
            return False
        if not rb_encode_bool(obj_val[key], buf):
            return False
        i = i + 1
    rb_val["pos"] = buf["pos"]
    return True

def rb_decode_bool_dict(rb_val, offset):
    obj_val = {}
    buf = rb_nested_buf(rb_val, offset)
    if buf["size"] < 1:
        return (None, False)
    size = rb_get_array_count(buf)
    if size < 1:
        return (obj_val, True)
    rc = True
    for i in xrange(size):
        (off, ok) = rb_get_array_table_item(i, buf)
        if not ok:
            rc = False
            break
        (key, ok) = rb_decode_string(buf, off)
        if not ok:
            rc = False
            break
        delta = rb_sizeof_string(key)
        (val, ok) = rb_decode_bool(buf, off + delta)
        if not ok:
            rc = False
            break
        obj_val[key] = val
    return (obj_val, rc)

def rb_eq_int8_dict(src, dst):
    ssize = len(src)
    dsize = len(dst)
    if ssize != dsize:
        return False
    for key in src:
        if not key in dst:
            return False
        if src[key] != dst[key]:
            return False
    return True

def rb_sizeof_int8_dict(obj_val):
    size = sizeof_rb_size + len(obj_val) * sizeof_rb_size
    for key in obj_val:
        size += rb_sizeof_string(key)
        size += rb_sizeof_int8(obj_val[key])
    return size

def rb_encode_int8_dict(obj_val, rb_val):
    buf = rb_nested_buf(rb_val, 0)
    if buf["size"] < 1:
        return False
    count = len(obj_val)
    if not rb_set_array_count(count, buf):
        return False
    i = 0
    for key in obj_val:
        if not rb_set_array_table_item(i, buf["pos"] - buf["start"], buf):
            return False
        if not rb_encode_string(key, buf):
            return False
        if not rb_encode_int8(obj_val[key], buf):
            return False
        i = i + 1
    rb_val["pos"] = buf["pos"]
    return True

def rb_decode_int8_dict(rb_val, offset):
    obj_val = {}
    buf = rb_nested_buf(rb_val, offset)
    if buf["size"] < 1:
        return (None, False)
    size = rb_get_array_count(buf)
    if size < 1:
        return (obj_val, True)
    rc = True
    for i in xrange(size):
        (off, ok) = rb_get_array_table_item(i, buf)
        if not ok:
            rc = False
            break
        (key, ok) = rb_decode_string(buf, off)
        if not ok:
            rc = False
            break
        delta = rb_sizeof_string(key)
        (val, ok) = rb_decode_int8(buf, off + delta)
        if not ok:
            rc = False
            break
        obj_val[key] = val
    return (obj_val, rc)

def rb_eq_uint8_dict(src, dst):
    ssize = len(src)
    dsize = len(dst)
    if ssize != dsize:
        return False
    for key in src:
        if not key in dst:
            return False
        if src[key] != dst[key]:
            return False
    return True

def rb_sizeof_uint8_dict(obj_val):
    size = sizeof_rb_size + len(obj_val) * sizeof_rb_size
    for key in obj_val:
        size += rb_sizeof_string(key)
        size += rb_sizeof_uint8(obj_val[key])
    return size

def rb_encode_uint8_dict(obj_val, rb_val):
    buf = rb_nested_buf(rb_val, 0)
    if buf["size"] < 1:
        return False
    count = len(obj_val)
    if not rb_set_array_count(count, buf):
        return False
    i = 0
    for key in obj_val:
        if not rb_set_array_table_item(i, buf["pos"] - buf["start"], buf):
            return False
        if not rb_encode_string(key, buf):
            return False
        if not rb_encode_uint8(obj_val[key], buf):
            return False
        i = i + 1
    rb_val["pos"] = buf["pos"]
    return True

def rb_decode_uint8_dict(rb_val, offset):
    obj_val = {}
    buf = rb_nested_buf(rb_val, offset)
    if buf["size"] < 1:
        return (None, False)
    size = rb_get_array_count(buf)
    if size < 1:
        return (obj_val, True)
    rc = True
    for i in xrange(size):
        (off, ok) = rb_get_array_table_item(i, buf)
        if not ok:
            rc = False
            break
        (key, ok) = rb_decode_string(buf, off)
        if not ok:
            rc = False
            break
        delta = rb_sizeof_string(key)
        (val, ok) = rb_decode_uint8(buf, off + delta)
        if not ok:
            rc = False
            break
        obj_val[key] = val
    return (obj_val, rc)

def rb_eq_int16_dict(src, dst):
    ssize = len(src)
    dsize = len(dst)
    if ssize != dsize:
        return False
    for key in src:
        if not key in dst:
            return False
        if src[key] != dst[key]:
            return False
    return True

def rb_sizeof_int16_dict(obj_val):
    size = sizeof_rb_size + len(obj_val) * sizeof_rb_size
    for key in obj_val:
        size += rb_sizeof_string(key)
        size += rb_sizeof_int16(obj_val[key])
    return size

def rb_encode_int16_dict(obj_val, rb_val):
    buf = rb_nested_buf(rb_val, 0)
    if buf["size"] < 1:
        return False
    count = len(obj_val)
    if not rb_set_array_count(count, buf):
        return False
    i = 0
    for key in obj_val:
        if not rb_set_array_table_item(i, buf["pos"] - buf["start"], buf):
            return False
        if not rb_encode_string(key, buf):
            return False
        if not rb_encode_int16(obj_val[key], buf):
            return False
        i = i + 1
    rb_val["pos"] = buf["pos"]
    return True

def rb_decode_int16_dict(rb_val, offset):
    obj_val = {}
    buf = rb_nested_buf(rb_val, offset)
    if buf["size"] < 1:
        return (None, False)
    size = rb_get_array_count(buf)
    if size < 1:
        return (obj_val, True)
    rc = True
    for i in xrange(size):
        (off, ok) = rb_get_array_table_item(i, buf)
        if not ok:
            rc = False
            break
        (key, ok) = rb_decode_string(buf, off)
        if not ok:
            rc = False
            break
        delta = rb_sizeof_string(key)
        (val, ok) = rb_decode_int16(buf, off + delta)
        if not ok:
            rc = False
            break
        obj_val[key] = val
    return (obj_val, rc)

def rb_eq_uint16_dict(src, dst):
    ssize = len(src)
    dsize = len(dst)
    if ssize != dsize:
        return False
    for key in src:
        if not key in dst:
            return False
        if src[key] != dst[key]:
            return False
    return True

def rb_sizeof_uint16_dict(obj_val):
    size = sizeof_rb_size + len(obj_val) * sizeof_rb_size
    for key in obj_val:
        size += rb_sizeof_string(key)
        size += rb_sizeof_uint16(obj_val[key])
    return size

def rb_encode_uint16_dict(obj_val, rb_val):
    buf = rb_nested_buf(rb_val, 0)
    if buf["size"] < 1:
        return False
    count = len(obj_val)
    if not rb_set_array_count(count, buf):
        return False
    i = 0
    for key in obj_val:
        if not rb_set_array_table_item(i, buf["pos"] - buf["start"], buf):
            return False
        if not rb_encode_string(key, buf):
            return False
        if not rb_encode_uint16(obj_val[key], buf):
            return False
        i = i + 1
    rb_val["pos"] = buf["pos"]
    return True

def rb_decode_uint16_dict(rb_val, offset):
    obj_val = {}
    buf = rb_nested_buf(rb_val, offset)
    if buf["size"] < 1:
        return (None, False)
    size = rb_get_array_count(buf)
    if size < 1:
        return (obj_val, True)
    rc = True
    for i in xrange(size):
        (off, ok) = rb_get_array_table_item(i, buf)
        if not ok:
            rc = False
            break
        (key, ok) = rb_decode_string(buf, off)
        if not ok:
            rc = False
            break
        delta = rb_sizeof_string(key)
        (val, ok) = rb_decode_uint16(buf, off + delta)
        if not ok:
            rc = False
            break
        obj_val[key] = val
    return (obj_val, rc)

def rb_eq_int32_dict(src, dst):
    ssize = len(src)
    dsize = len(dst)
    if ssize != dsize:
        return False
    for key in src:
        if not key in dst:
            return False
        if src[key] != dst[key]:
            return False
    return True

def rb_sizeof_int32_dict(obj_val):
    size = sizeof_rb_size + len(obj_val) * sizeof_rb_size
    for key in obj_val:
        size += rb_sizeof_string(key)
        size += rb_sizeof_int32(obj_val[key])
    return size

def rb_encode_int32_dict(obj_val, rb_val):
    buf = rb_nested_buf(rb_val, 0)
    if buf["size"] < 1:
        return False
    count = len(obj_val)
    if not rb_set_array_count(count, buf):
        return False
    i = 0
    for key in obj_val:
        if not rb_set_array_table_item(i, buf["pos"] - buf["start"], buf):
            return False
        if not rb_encode_string(key, buf):
            return False
        if not rb_encode_int32(obj_val[key], buf):
            return False
        i = i + 1
    rb_val["pos"] = buf["pos"]
    return True

def rb_decode_int32_dict(rb_val, offset):
    obj_val = {}
    buf = rb_nested_buf(rb_val, offset)
    if buf["size"] < 1:
        return (None, False)
    size = rb_get_array_count(buf)
    if size < 1:
        return (obj_val, True)
    rc = True
    for i in xrange(size):
        (off, ok) = rb_get_array_table_item(i, buf)
        if not ok:
            rc = False
            break
        (key, ok) = rb_decode_string(buf, off)
        if not ok:
            rc = False
            break
        delta = rb_sizeof_string(key)
        (val, ok) = rb_decode_int32(buf, off + delta)
        if not ok:
            rc = False
            break
        obj_val[key] = val
    return (obj_val, rc)

def rb_eq_uint32_dict(src, dst):
    ssize = len(src)
    dsize = len(dst)
    if ssize != dsize:
        return False
    for key in src:
        if not key in dst:
            return False
        if src[key] != dst[key]:
            return False
    return True

def rb_sizeof_uint32_dict(obj_val):
    size = sizeof_rb_size + len(obj_val) * sizeof_rb_size
    for key in obj_val:
        size += rb_sizeof_string(key)
        size += rb_sizeof_uint32(obj_val[key])
    return size

def rb_encode_uint32_dict(obj_val, rb_val):
    buf = rb_nested_buf(rb_val, 0)
    if buf["size"] < 1:
        return False
    count = len(obj_val)
    if not rb_set_array_count(count, buf):
        return False
    i = 0
    for key in obj_val:
        if not rb_set_array_table_item(i, buf["pos"] - buf["start"], buf):
            return False
        if not rb_encode_string(key, buf):
            return False
        if not rb_encode_uint32(obj_val[key], buf):
            return False
        i = i + 1
    rb_val["pos"] = buf["pos"]
    return True

def rb_decode_uint32_dict(rb_val, offset):
    obj_val = {}
    buf = rb_nested_buf(rb_val, offset)
    if buf["size"] < 1:
        return (None, False)
    size = rb_get_array_count(buf)
    if size < 1:
        return (obj_val, True)
    rc = True
    for i in xrange(size):
        (off, ok) = rb_get_array_table_item(i, buf)
        if not ok:
            rc = False
            break
        (key, ok) = rb_decode_string(buf, off)
        if not ok:
            rc = False
            break
        delta = rb_sizeof_string(key)
        (val, ok) = rb_decode_uint32(buf, off + delta)
        if not ok:
            rc = False
            break
        obj_val[key] = val
    return (obj_val, rc)

def rb_eq_int64_dict(src, dst):
    ssize = len(src)
    dsize = len(dst)
    if ssize != dsize:
        return False
    for key in src:
        if not key in dst:
            return False
        if src[key] != dst[key]:
            return False
    return True

def rb_sizeof_int64_dict(obj_val):
    size = sizeof_rb_size + len(obj_val) * sizeof_rb_size
    for key in obj_val:
        size += rb_sizeof_string(key)
        size += rb_sizeof_int64(obj_val[key])
    return size

def rb_encode_int64_dict(obj_val, rb_val):
    buf = rb_nested_buf(rb_val, 0)
    if buf["size"] < 1:
        return False
    count = len(obj_val)
    if not rb_set_array_count(count, buf):
        return False
    i = 0
    for key in obj_val:
        if not rb_set_array_table_item(i, buf["pos"] - buf["start"], buf):
            return False
        if not rb_encode_string(key, buf):
            return False
        if not rb_encode_int64(obj_val[key], buf):
            return False
        i = i + 1
    rb_val["pos"] = buf["pos"]
    return True

def rb_decode_int64_dict(rb_val, offset):
    obj_val = {}
    buf = rb_nested_buf(rb_val, offset)
    if buf["size"] < 1:
        return (None, False)
    size = rb_get_array_count(buf)
    if size < 1:
        return (obj_val, True)
    rc = True
    for i in xrange(size):
        (off, ok) = rb_get_array_table_item(i, buf)
        if not ok:
            rc = False
            break
        (key, ok) = rb_decode_string(buf, off)
        if not ok:
            rc = False
            break
        delta = rb_sizeof_string(key)
        (val, ok) = rb_decode_int64(buf, off + delta)
        if not ok:
            rc = False
            break
        obj_val[key] = val
    return (obj_val, rc)

def rb_eq_uint64_dict(src, dst):
    ssize = len(src)
    dsize = len(dst)
    if ssize != dsize:
        return False
    for key in src:
        if not key in dst:
            return False
        if src[key] != dst[key]:
            return False
    return True

def rb_sizeof_uint64_dict(obj_val):
    size = sizeof_rb_size + len(obj_val) * sizeof_rb_size
    for key in obj_val:
        size += rb_sizeof_string(key)
        size += rb_sizeof_uint64(obj_val[key])
    return size

def rb_encode_uint64_dict(obj_val, rb_val):
    buf = rb_nested_buf(rb_val, 0)
    if buf["size"] < 1:
        return False
    count = len(obj_val)
    if not rb_set_array_count(count, buf):
        return False
    i = 0
    for key in obj_val:
        if not rb_set_array_table_item(i, buf["pos"] - buf["start"], buf):
            return False
        if not rb_encode_string(key, buf):
            return False
        if not rb_encode_uint64(obj_val[key], buf):
            return False
        i = i + 1
    rb_val["pos"] = buf["pos"]
    return True

def rb_decode_uint64_dict(rb_val, offset):
    obj_val = {}
    buf = rb_nested_buf(rb_val, offset)
    if buf["size"] < 1:
        return (None, False)
    size = rb_get_array_count(buf)
    if size < 1:
        return (obj_val, True)
    rc = True
    for i in xrange(size):
        (off, ok) = rb_get_array_table_item(i, buf)
        if not ok:
            rc = False
            break
        (key, ok) = rb_decode_string(buf, off)
        if not ok:
            rc = False
            break
        delta = rb_sizeof_string(key)
        (val, ok) = rb_decode_uint64(buf, off + delta)
        if not ok:
            rc = False
            break
        obj_val[key] = val
    return (obj_val, rc)

def rb_eq_float_dict(src, dst):
    ssize = len(src)
    dsize = len(dst)
    if ssize != dsize:
        return False
    for key in src:
        if not key in dst:
            return False
        if src[key] != dst[key]:
            return False
    return True

def rb_sizeof_float_dict(obj_val):
    size = sizeof_rb_size + len(obj_val) * sizeof_rb_size
    for key in obj_val:
        size += rb_sizeof_string(key)
        size += rb_sizeof_float(obj_val[key])
    return size

def rb_encode_float_dict(obj_val, rb_val):
    buf = rb_nested_buf(rb_val, 0)
    if buf["size"] < 1:
        return False
    count = len(obj_val)
    if not rb_set_array_count(count, buf):
        return False
    i = 0
    for key in obj_val:
        if not rb_set_array_table_item(i, buf["pos"] - buf["start"], buf):
            return False
        if not rb_encode_string(key, buf):
            return False
        if not rb_encode_float(obj_val[key], buf):
            return False
        i = i + 1
    rb_val["pos"] = buf["pos"]
    return True

def rb_decode_float_dict(rb_val, offset):
    obj_val = {}
    buf = rb_nested_buf(rb_val, offset)
    if buf["size"] < 1:
        return (None, False)
    size = rb_get_array_count(buf)
    if size < 1:
        return (obj_val, True)
    rc = True
    for i in xrange(size):
        (off, ok) = rb_get_array_table_item(i, buf)
        if not ok:
            rc = False
            break
        (key, ok) = rb_decode_string(buf, off)
        if not ok:
            rc = False
            break
        delta = rb_sizeof_string(key)
        (val, ok) = rb_decode_float(buf, off + delta)
        if not ok:
            rc = False
            break
        obj_val[key] = val
    return (obj_val, rc)

def rb_eq_double_dict(src, dst):
    ssize = len(src)
    dsize = len(dst)
    if ssize != dsize:
        return False
    for key in src:
        if not key in dst:
            return False
        if src[key] != dst[key]:
            return False
    return True

def rb_sizeof_double_dict(obj_val):
    size = sizeof_rb_size + len(obj_val) * sizeof_rb_size
    for key in obj_val:
        size += rb_sizeof_string(key)
        size += rb_sizeof_double(obj_val[key])
    return size

def rb_encode_double_dict(obj_val, rb_val):
    buf = rb_nested_buf(rb_val, 0)
    if buf["size"] < 1:
        return False
    count = len(obj_val)
    if not rb_set_array_count(count, buf):
        return False
    i = 0
    for key in obj_val:
        if not rb_set_array_table_item(i, buf["pos"] - buf["start"], buf):
            return False
        if not rb_encode_string(key, buf):
            return False
        if not rb_encode_double(obj_val[key], buf):
            return False
        i = i + 1
    rb_val["pos"] = buf["pos"]
    return True

def rb_decode_double_dict(rb_val, offset):
    obj_val = {}
    buf = rb_nested_buf(rb_val, offset)
    if buf["size"] < 1:
        return (None, False)
    size = rb_get_array_count(buf)
    if size < 1:
        return (obj_val, True)
    rc = True
    for i in xrange(size):
        (off, ok) = rb_get_array_table_item(i, buf)
        if not ok:
            rc = False
            break
        (key, ok) = rb_decode_string(buf, off)
        if not ok:
            rc = False
            break
        delta = rb_sizeof_string(key)
        (val, ok) = rb_decode_double(buf, off + delta)
        if not ok:
            rc = False
            break
        obj_val[key] = val
    return (obj_val, rc)

def rb_eq_string_dict(src, dst):
    ssize = len(src)
    dsize = len(dst)
    if ssize != dsize:
        return False
    for key in src:
        if not key in dst:
            return False
        if src[key] != dst[key]:
            return False
    return True

def rb_sizeof_string_dict(obj_val):
    size = sizeof_rb_size + len(obj_val) * sizeof_rb_size
    for key in obj_val:
        size += rb_sizeof_string(key)
        size += rb_sizeof_string(obj_val[key])
    return size

def rb_encode_string_dict(obj_val, rb_val):
    buf = rb_nested_buf(rb_val, 0)
    if buf["size"] < 1:
        return False
    count = len(obj_val)
    if not rb_set_array_count(count, buf):
        return False
    i = 0
    for key in obj_val:
        if not rb_set_array_table_item(i, buf["pos"] - buf["start"], buf):
            return False
        if not rb_encode_string(key, buf):
            return False
        if not rb_encode_string(obj_val[key], buf):
            return False
        i = i + 1
    rb_val["pos"] = buf["pos"]
    return True

def rb_decode_string_dict(rb_val, offset):
    obj_val = {}
    buf = rb_nested_buf(rb_val, offset)
    if buf["size"] < 1:
        return (None, False)
    size = rb_get_array_count(buf)
    if size < 1:
        return (obj_val, True)
    rc = True
    for i in xrange(size):
        (off, ok) = rb_get_array_table_item(i, buf)
        if not ok:
            rc = False
            break
        (key, ok) = rb_decode_string(buf, off)
        if not ok:
            rc = False
            break
        delta = rb_sizeof_string(key)
        (val, ok) = rb_decode_string(buf, off + delta)
        if not ok:
            rc = False
            break
        obj_val[key] = val
    return (obj_val, rc)

if __name__ == "__main__":
    pass